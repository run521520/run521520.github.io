<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>逆向工程权威指南上</title>
    <link href="/2025/10/10/reverse_books/"/>
    <url>/2025/10/10/reverse_books/</url>
    
    <content type="html"><![CDATA[<h2 id="1-CPU简介"><a href="#1-CPU简介" class="headerlink" title="1. CPU简介"></a>1. CPU简介</h2><p>CPU是执行机器码的硬件单元，可以叫它中央处理器，相当于人的大脑，处理各种信息，机器码就是信息<br>而这些信息储存在内存中。<br><strong>CPU最基本工作方式</strong>：</p><ol><li>取指令：从内存中读取下一条要执行的指令。</li><li>解码指令：搞清楚这条指令是什么意思，是运算？还是内存加载数据。</li><li>执行指令：实际完成指令所要求的操作，比如让加法器开始计算。</li></ol><p>机器码就是由01这两种组成的，形成各种信息。<br>cpu是怎么识别机器码的呢？</p><blockquote><p>我自己的理解就是CPU本身就是由上百亿个<strong>晶体管</strong>构成的，<strong>晶体管</strong>可以看成一个用电控制<br>的微型开关，给它一个高电压(代表[1]),开关就打开了，低电压就是[0],电流中断<br>当它读取指令(机器码)的时候，根据高低电压(0,1) 就会形成不同的组合信息</p></blockquote><p>上面说了，指令储存在内存中，每次CPU都要从内存中拿指令，实在是太麻烦了，所以CPU也有内置的内存<br>叫做<strong>寄存器</strong>，用于储存当前正在被处理的指令，数据或内存地址，访问速度肯定比外面的快<br>不同的CPU也有差别：<br>x86CPU的寄存器(GPR)一般有8个GPR,X64往往有16个GPR，ARM也是有16个。<br>不同的寄存器肯定功能也不一样，后面讲。</p><p>根据机器码，又有了方便人类看懂的汇编语言，毕竟谁会面对只有01的代码一辈子呢？<br>汇编语言可以说是机器码的表现形式，更容易人们对cpu下指令<br>CPU执行的机器码，那我们用高级语言的时候，它是怎么处理的呢？</p><blockquote><p>这里是编译器&#x2F;Compiler 的功能，可以将高级语言转换为CPU受理的底层汇编语言</p></blockquote><h3 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h3><p>你可以吧<strong>指令集架构</strong>想象成CPU的<strong>母语</strong>或<strong>方言</strong><br><strong>CPU</strong>是一个只会说方言的工人<br>指令集就是这种方言的语法规范，它规定了CPU能听懂哪些命令，<br>我们写的所有程序(c++,py,java等)，最终都必须被翻译为CPU能听懂的<strong>方言</strong></p><p>就像中文，英文，日文一样，指令架构也有不同如x86,x64,ARM,MIPS等<br>这里就不细讲，因为我也不知道，还待学~。</p><h2 id="2-最简函数"><a href="#2-最简函数" class="headerlink" title="2. 最简函数"></a>2. 最简函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;&#125;<br><span class="hljs-comment">//非常简单的自定义函数</span><br></code></pre></td></tr></table></figure><h3 id="用x86表现"><a href="#用x86表现" class="headerlink" title="用x86表现"></a>用x86表现</h3><p>GCC是用于反编译x86汇编指令的编译器</p><p>f:<br>moveax,  123<br>ret<br><br>MSVC编译器的和上面一样。<br>分析一下：这个函数仅由两条指令构成：第一条将<strong>123</strong>存放到EAX寄存器里；根据函数调用约定<br>后面一条指令会把EAX的值当作返回值传递给调用者函数，而调用者函数(caller)会从EAX寄存器<br>里取值，把它当作返回结果。</p><h3 id="用ARM表现"><a href="#用ARM表现" class="headerlink" title="用ARM表现"></a>用ARM表现</h3><p>Keil编译器</p><p>f PROC<br>MOVr0,#0x7b ; 123<br>BX      lr<br>ENDP</p><p>ARM程序使用R0寄存器传递函数返回值，所以指令把数值123赋值给R0<br>ARM程序使用LR寄存器储存函数结束之后的返回地址。x86程序使用<strong>栈</strong><br>结构储存上述返回地址。 BX LR 指令的作用是跳转到返回地址，即返回到调用<br>者函数，然后继续执行后续命令</p><h3 id="用MIPS表现"><a href="#用MIPS表现" class="headerlink" title="用MIPS表现"></a>用MIPS表现</h3><p>博主等以后在学，现在用不到，用到什么学什么</p><h2 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3. Hello,world!"></a>3. Hello,world!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//非常著名的程序</span><br></code></pre></td></tr></table></figure><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><h4 id="用MSVC生成汇编"><a href="#用MSVC生成汇编" class="headerlink" title="- 用MSVC生成汇编"></a>- 用MSVC生成汇编</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>CONSTSEGMENT<br>$SG3830 DB &#x27;Hello,world!&#x27;, OAH, ООH<br>CONST ENDS<br><br>PUBLIC _main<br>EXTRN _printf: PROC<br>; Function compile flags: /0dtp<br><br>_TEXT SEGMENT<br>_main PROC<br>push ebp<br>mov  ebp, esp<br>push OFFSET $SG3830<br>call _printf<br>add  esp, 4<br>xor  eax, eax<br>pop  ebp<br>ret  0<br>_main ENDP<br>_TEXT ENDS<br><br></code></pre></td></tr></table></figure><p>这段代码主要分为两个代码段，即CONST和_TEXT段，它们分别代表数据段和代码段</p><ul><li><p>在CONST段：<br>将字符串 Hello,world! 赋值给  $SG3830</p></li><li><p>在_TEXT段：<br>只有一个函数 即主函数main()。在汇编中，主函数的函数体有标志性的<strong>函数序言</strong>和<strong>函数尾声</strong><br>通过push指令将变量$SG3830压入栈。这样_printf就可以调用栈中的指针即’Hello,world!’<br>的地址，调用完成后，$SG3830仍然在栈中，这时候就需要调整栈指针(ESP里的值)，来释放<br>这个指针，所以下一条语句 add esp,4 就是栈指针里的值加4(因为x86是32位4字节)，<br>相当于POP出栈，但是不同是本例是舍弃栈里的数据而POP还要把寄存器里的值存储到既定寄存器<br>然后便是 xor 异或 xor eax , eax 值为0</p></li></ul><h4 id="用GCC编译"><a href="#用GCC编译" class="headerlink" title="- 用GCC编译"></a>- 用GCC编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">Main    proc near<br>var 10  =  dword ptr-10h<br>push ebp<br>mov  ebp, esp<br>and  esp, OFFFFFFF0h<br>sub  esp, 10h<br>mov  eax, offset aHelloWorld; &quot;Hello,world!\n&quot;<br>mov  [esp+10h+var_10], eax<br>call  printf<br>mov  eax, 0<br>leave<br>retn<br>main    endp<br></code></pre></td></tr></table></figure><pre><code class="hljs">GCC生成的汇编指令，与MSVC生成的基本相同,开头 AND ESP, OFFFFFFF0h 指令。它令栈地址</code></pre><p>(ESP的值) 向16字节边界对齐，属于初始话的指令。如果地址没对齐，CPU可能需要访问两次内存<br>才能获取栈内数据。虽然在8字节边界处对齐就可以满足32位x86 CPU 和 64位 x64 CPU的要求,但是<br>主流编译器的编译规则规定“程序访问的地址必须向16字节对齐(被16整除)”。人们还是为了提高指令<br>的执行效率而特意拟定了这条编译规范。<br>SUB ESP,10h 在栈中分配16个字节(这里10h &#x3D; hex(10))，而后便是将字符串地址(指针的值)<br>写入到栈中，此处 GCC用的是 MOV 而MSVC用的是 PUSH 指令。<br>mov  [esp+10h+var_10], eax 中的var_10是局部变量，用来向后面printf()函数传递参数<br>mov eax, 0 将eax归零，这里和MSVC又不同， mov指令的opcode是4，而xor的opcode是2</p><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="- x86-64"></a>- x86-64</h4><h2 id="4-函数序言和函数尾声"><a href="#4-函数序言和函数尾声" class="headerlink" title="4. 函数序言和函数尾声"></a>4. 函数序言和函数尾声</h2><h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5. 栈"></a>5. 栈</h2><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RC4加密算法</title>
    <link href="/2025/10/04/02_RC4/"/>
    <url>/2025/10/04/02_RC4/</url>
    
    <content type="html"><![CDATA[<p><strong>RC4 是典型的对称加密算法</strong></p><p>对称加密的核心特征是加密与解密过程依托同一密钥完成。在数据传输场景中：</p><p>发送方：利用密钥对明文执行加密变换，通过特殊算法将明文转化为复杂密文后对外传输；</p><p>接收方：需调用加密时的相同密钥，结合算法的逆运算对密文解密，还原出可读明文，以此保障数据传输的保密性。</p><p><strong>RC4 算法特性与安全性</strong></p><p>RC4 算法具备实现简单、运算高效的优势，其密钥长度支持动态调整，范围覆盖 1 - 256 字节（对应 8 - 2048 比特） 。加密时，会依据密钥及密钥长度生成密钥流，且密钥流长度与明文长度严格匹配，加密和解密流程复用同一算法逻辑，密钥流的生成完全由密钥内容与长度决定。</p><p>在现代技术环境下，当密钥长度达到 128 比特时，暴力枚举密钥的攻击方式已不具备可行性 。由于暴力破解需尝试近乎 “2^128” 数量级的密钥组合，计算量超乎现有算力承载极限，因此可预见在未来较长周期内，RC4 算法凭借其密钥长度设计，能够抵御暴力密钥搜索攻击。截至目前，针对 128 比特密钥长度的 RC4 加密，尚未出现经实践验证的有效攻击手段，一定程度上保障了算法应用的安全性。</p><p><strong>RC4 算法核心组成</strong></p><p>RC4 加密流程主要由两部分构成：</p><p>初始化算法（KSA，Key - Scheduling Algorithm）：负责对初始的密钥状态进行处理，基于输入密钥打乱内部状态数组，为后续生成密钥流做准备；</p><p>加密算法（PRGA，Pseudo - Random Generation Algorithm ，实际常与 KSA 协同表述）：依托 KSA 初始化后的状态，逐字节生成伪随机密钥流，通过密钥流与明文的按位异或（XOR）操作，完成加密（解密为逆过程，复用相同密钥流与异或逻辑 ），最终输出密文（或还原明文 ）。</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>&#x2F;&#x2F; 初始化RC4的S盒</p><p>void rc4_init(unsigned char *s, unsigned char *key, unsigned long key_len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0;</p><p>&nbsp;   unsigned char k[256] &#x3D; {0};</p><p>&nbsp;   unsigned char temp &#x3D; 0;</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 初始化S盒和K盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       s[i] &#x3D; i;</p><p>&nbsp;       k[i] &#x3D; key[i % key_len];  &#x2F;&#x2F; 用密钥循环填充K盒</p><p>&nbsp;   }</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 打乱S盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       j &#x3D; (j + s[i] + k[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;   }</p><p>}</p><p>&#x2F;&#x2F; RC4加解密（数据会被直接修改）</p><p>void rc4_crypt(unsigned char *s, unsigned char *data, unsigned long len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;</p><p>&nbsp;   unsigned long k &#x3D; 0;</p><p>&nbsp;   unsigned char temp;</p><p>&nbsp;   </p><p>&nbsp;   for (k &#x3D; 0; k &lt; len; k++) {</p><p>&nbsp;       i &#x3D; (i + 1) % 256;</p><p>&nbsp;       j &#x3D; (j + s[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;       &#x2F;&#x2F; 生成密钥流并异或</p><p>&nbsp;       t &#x3D; (s[i] + s[j]) % 256;</p><p>&nbsp;       data[k] ^&#x3D; s[t];</p><p>&nbsp;   }</p><p>}</p><p>int main() {</p><p>&nbsp;   unsigned char s[256] &#x3D; {0};</p><p>&nbsp;   char key[] &#x3D; “zhaosh”;               &#x2F;&#x2F; 密钥</p><p>&nbsp;   unsigned char data[] &#x3D; {12, 23, 3, 4, 4, 4, 3, 0x7F, 12, 1, 21, 3, 23};  &#x2F;&#x2F; 修正超出char范围的值</p><p>&nbsp;   unsigned long data_len &#x3D; sizeof(data);  &#x2F;&#x2F; 用sizeof计算二进制数据长度</p><p>&nbsp;   unsigned long key_len &#x3D; strlen(key);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 加密过程</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“加密后数据（十六进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%02X “, data[i]);  &#x2F;&#x2F; 用十六进制显示二进制数据</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 解密过程（需要重新初始化S盒）</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);  &#x2F;&#x2F; 重新初始化</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“解密后数据（十进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%d “, data[i]);</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   return 0;</p><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ida使用文档</title>
    <link href="/2025/10/04/01_ida/"/>
    <url>/2025/10/04/01_ida/</url>
    
    <content type="html"><![CDATA[<h1 id="IDA-使用文档"><a href="#IDA-使用文档" class="headerlink" title="IDA 使用文档"></a>IDA 使用文档</h1><h2 id="一、窗口介绍"><a href="#一、窗口介绍" class="headerlink" title="一、窗口介绍"></a>一、窗口介绍</h2><h3 id="1-函数窗口"><a href="#1-函数窗口" class="headerlink" title="1. 函数窗口"></a>1. 函数窗口</h3><ul><li><strong>功能</strong>：显示所有函数列表。</li><li><strong>快捷键</strong>：<code>Ctrl + F</code> 查找函数名（所有表格窗口均支持）。</li></ul><h3 id="2-IDA-View-窗口"><a href="#2-IDA-View-窗口" class="headerlink" title="2. IDA-View 窗口"></a>2. IDA-View 窗口</h3><ul><li><strong>功能</strong>：显示汇编代码。</li><li><strong>快捷键</strong>：<code>空格键</code> 切换图形模式与文本模式。</li></ul><h3 id="3-Pseudocode（伪代码）窗口"><a href="#3-Pseudocode（伪代码）窗口" class="headerlink" title="3. Pseudocode（伪代码）窗口"></a>3. Pseudocode（伪代码）窗口</h3><ul><li><strong>功能</strong>：显示 C&#x2F;C++ 伪代码。</li><li><strong>快捷键</strong>：<code>Tab</code> 切换到对应汇编窗口。</li><li><strong>重命名</strong>：选中关键词后按 <code>N</code>，或右键选择“Rename global item”。</li></ul><h3 id="4-字符串窗口"><a href="#4-字符串窗口" class="headerlink" title="4. 字符串窗口"></a>4. 字符串窗口</h3><ul><li><strong>功能</strong>：列举程序引用的字符串常量。</li><li><strong>快捷键</strong>：<code>Shift + F12</code> 打开字符串窗口；<code>Ctrl + F</code> 搜索字符串。</li></ul><h3 id="5-其他窗口"><a href="#5-其他窗口" class="headerlink" title="5. 其他窗口"></a>5. 其他窗口</h3><ul><li><strong>HEX View</strong>：内存十六进制视图</li><li><strong>Exports</strong>：导出函数</li><li><strong>Imports</strong>：导入函数</li><li><strong>Structures</strong>：结构体定义</li></ul><blockquote><p><strong>提示</strong>：大部分窗口入口可在菜单栏 <code>View</code> 中找到。</p></blockquote><hr><h2 id="二、常用快捷键"><a href="#二、常用快捷键" class="headerlink" title="二、常用快捷键"></a>二、常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Ctrl + X</code></td><td>查看交叉引用（字符串&#x2F;变量被引用的函数）</td></tr><tr><td><code>Ctrl + Z</code></td><td>撤销操作</td></tr><tr><td><code>Alt + T</code></td><td>查找汇编指令，<code>F3</code> 查找下一个</td></tr><tr><td><code>Alt + M</code></td><td>添加标签描述</td></tr><tr><td><code>Ctrl + M</code></td><td>搜索标签并跳转</td></tr><tr><td><code>\</code></td><td>隐藏&#x2F;显示类型转换（如 <code>*(_DWORD *)</code>）</td></tr><tr><td><code>F5</code>&#x2F;<code>Tab</code></td><td>反编译为 C 伪代码窗口</td></tr><tr><td><code>H</code></td><td>十六进制与十进制切换（Hex-View）</td></tr><tr><td><code>D</code></td><td>转换字节显示方式</td></tr><tr><td><code>U</code></td><td>拆分字节数据</td></tr><tr><td><code>C</code></td><td>重新分析为汇编代码</td></tr><tr><td><code>/</code></td><td>汇编界面显示伪代码（需支持 F5）</td></tr><tr><td><code>R</code></td><td>转换为字符串类型显示</td></tr><tr><td><code>N</code></td><td>修改变量&#x2F;函数名称</td></tr><tr><td><code>Y</code></td><td>修改变量类型</td></tr><tr><td><code>M</code></td><td>查看 API 参数名称</td></tr><tr><td><code>P</code></td><td>重新生成函数</td></tr></tbody></table><hr><h2 id="三、IDA-调试器功能"><a href="#三、IDA-调试器功能" class="headerlink" title="三、IDA 调试器功能"></a>三、IDA 调试器功能</h2><ol><li><strong>断点类型</strong>：软件断点、硬件断点、条件断点、脚本断点</li><li><strong>调试控制</strong>：步入、步过、步出、运行到光标</li><li><strong>调试级别</strong>：汇编级、伪代码级、源码级</li><li><strong>寄存器&#x2F;内存</strong>：读写寄存器与内存</li><li><strong>调试方式</strong>：启动进程调试、附加调试</li></ol><h3 id="调试相关菜单功能"><a href="#调试相关菜单功能" class="headerlink" title="调试相关菜单功能"></a>调试相关菜单功能</h3><ul><li><strong>Quick debug view</strong>：快速查看寄存器、内存等关键信息</li><li><strong>Debugger windows</strong>：打开调试辅助窗口（如反汇编、寄存器、内存等）</li><li><strong>Breakpoints</strong>：设置、编辑、删除、管理断点</li><li><strong>Watches</strong>：监视变量或表达式的值</li><li><strong>Tracing</strong>：记录程序执行轨迹，便于分析流程</li><li><strong>Start process</strong>：<code>F9</code> 启动新进程并调试</li><li><strong>Attach to process</strong>：附加到已运行进程或远程进程</li><li><strong>Process options…</strong>：配置调试进程参数（环境变量、工作目录等）</li><li><strong>Pause process</strong>：暂停进程，检查当前状态</li><li><strong>Terminate process</strong>：终止进程</li><li><strong>Detach from process</strong>：分离调试器，进程继续运行</li><li><strong>Refresh memory</strong>：刷新内存视图</li><li><strong>Take memory snapshot</strong>：内存快照，便于对比分析</li><li><strong>Step into</strong>：<code>F7</code> 单步进入函数</li><li><strong>Step over</strong>：<code>F8</code> 单步跳过函数</li><li><strong>Run until return</strong>：<code>Ctrl + F7</code> 运行至当前函数返回</li><li><strong>Run to cursor</strong>：<code>F4</code> 运行到光标处</li><li><strong>Switch to source</strong>：切换到源代码视图</li><li><strong>Use source-level debugging</strong>：启用源码级调试</li><li><strong>Open source file…</strong>：打开源代码文件</li><li><strong>Debugger options…</strong>：调试器全局配置</li><li><strong>Switch debugger…</strong>：切换不同类型调试器</li></ul><hr><h2 id="四、内存修改技巧"><a href="#四、内存修改技巧" class="headerlink" title="四、内存修改技巧"></a>四、内存修改技巧</h2><ul><li>在 <strong>Hex View</strong> 表中可直接修改内存数值。</li><li>找到要修改的位置，按 <code>F2</code> 进行编辑，再按一次 <code>F2</code> 确认修改。</li><li>右键选择 <code>Edit</code> 也可修改。</li><li>推荐插件：<strong>lazyIDA</strong>，可批量粘贴修改内容。</li></ul><hr><h2 id="五、调试技巧：通过修改-EIP-RIP-强制执行函数"><a href="#五、调试技巧：通过修改-EIP-RIP-强制执行函数" class="headerlink" title="五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数"></a>五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数</h2><ul><li><strong>EIP</strong>（32位）或 <strong>RIP</strong>（64位）寄存器存储 CPU 下一条指令地址。</li><li>修改 EIP&#x2F;RIP 可让 CPU 跳转执行任意函数。</li></ul><p><strong>操作步骤：</strong></p><ol><li>找到目标函数地址（十六进制）。</li><li>在合适位置设置断点，开始调试。</li><li>在寄存器窗口双击 EIP&#x2F;RIP，修改为目标地址（或右键 Edit）。</li><li>取消断点，继续运行即可。</li></ol><hr><blockquote><p>本文档适用于 IDA Pro 基础及进阶使用，欢迎在博客留言交流更多技巧！</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Base64加密算法</title>
    <link href="/2025/10/04/03_Base64/"/>
    <url>/2025/10/04/03_Base64/</url>
    
    <content type="html"><![CDATA[<p><strong>MD5和SHA256加密是不可逆的</strong></p><p><strong>base64是可逆的</strong></p><p>在python脚本中</p><p>开始要引入 base64</p><p>import 是引入的意思；</p><p><strong>import base64</strong></p><p>开始默认映射的是顺序是 <strong>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>要解密的为data</p><p><strong>data &#x3D; “SGVsbG8gV29ybGQ&#x3D;”</strong></p><p>则flag为</p><p><strong>flag_byte &#x3D; base64.b64decode(data)</strong></p><p>这里是base64调用 b64decode()函数 ，该函数是将已经加密的字符返回</p><p>b64decode() 函数返回的是字节，需要经过 decode(“utf-8”) 转换为字符串</p><p><strong>flag &#x3D; flag_byte.decode(“utf-8”)</strong></p><p><strong>print(flag)</strong></p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p><strong>有一些的变形：</strong></p><h4 id="映射改变了"><a href="#映射改变了" class="headerlink" title="映射改变了"></a><strong>映射改变了</strong></h4><p><strong>T1 &#x3D; “&#x2F;T+US9VR8WQ7XP6YO5ZN4aM3bL2cK1dJ0eIzfHygGxhFwiEvjDukCtlBsmArnqop”</strong></p><p><strong>target &#x3D; “NHPNOt5VdCixcy5JclLJLVHyLyauLMmC3CWeKl4lPRC&#x2F;“</strong></p><p>原本的是 :</p><p><strong>alphabet &#x3D; “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>创建映射表并转换：</p><p><strong>创建映射表：str.maketrans(x,y)</strong></p><p>x中的第一个字符映射到y中的第一个字符，以此类推</p><p><strong>根据映射表替换字符串中的字符: string.translate(table)</strong></p><p><strong>translation_table &#x3D; str.maketrans(T1,alphabet)</strong></p><p><strong>standard_encoded &#x3D; target.translate(translation_table)</strong></p><p><strong>解码：</strong></p><p><strong>decoded_bytes &#x3D; base64.b64decode(standard_encoded)</strong></p><p><strong>flag &#x3D; decoded_bytes.decode(‘utf-8’)</strong></p><p><strong>print(flag)</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TEA加密算法</title>
    <link href="/2025/10/04/04_TEA/"/>
    <url>/2025/10/04/04_TEA/</url>
    
    <content type="html"><![CDATA[<p>TEA、XTEA、XXTEA算法采用64位的明文分组和128位的密钥。算法中使用了一个神秘常数δ（delta），它来源于黄金比率，用于保证每一轮加密都不相同。δ的精确值并不关键，通常定义为δ&#x3D;「(√5 - 1)2^31」（即0x9E3779B9），在做题中可能会变，但没有影响。</p><p> <strong>密钥长度</strong></p><p>TEA：使用128位密钥。</p><p>XTEA：通常使用128位或256位密钥。</p><p>XXTEA：密钥长度更灵活，可以使用任意长度的密钥。</p><p>&nbsp;<strong>加密轮数</strong></p><p>TEA：通常进行32轮加密。</p><p>XTEA：默认进行64轮加密。</p><p>XXTEA：加密轮数更多，具体轮数取决于数据块和密钥的长度。</p><p><strong>加密算法</strong></p><p>TEA：加密过程使用简单的加法、异或和移位操作。</p><p>XTEA：在TEA的基础上增加了更多的变量和操作，例如密钥的不规则混合。</p><p>XXTEA：进一步改进了轮加密过程，使用了更多的变量和操作，并且利用相邻字进行加密。</p><h5 id="TEA加密算法（公式）："><a href="#TEA加密算法（公式）：" class="headerlink" title="TEA加密算法（公式）："></a>TEA加密算法（公式）：</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to 31</p><p>&nbsp;              sum +&#x3D; delta</p><p>&nbsp;X0 +&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;X1 +&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * 32;</p><p>&nbsp;for i&#x3D;0 to 31</p><p>&nbsp;X1 -&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;X0 -&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;sum -&#x3D; delta;</p><h5 id="XTEA加密算法（公式）"><a href="#XTEA加密算法（公式）" class="headerlink" title="XTEA加密算法（公式）:"></a>XTEA加密算法（公式）:</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;      X0 +&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;sum +&#x3D; delta</p><p>&nbsp;X1 +&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * Round;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;X1 -&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;sum -&#x3D; delta</p><p>&nbsp;      X0 -&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><h5 id="XXTEA加密（公式）："><a href="#XXTEA加密（公式）：" class="headerlink" title="XXTEA加密（公式）："></a>XXTEA加密（公式）：</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Upx脱壳</title>
    <link href="/2025/10/04/05_Upx/"/>
    <url>/2025/10/04/05_Upx/</url>
    
    <content type="html"><![CDATA[<p>upx壳是一种压缩的壳，正常进入ida中会隐藏真正的汇编代码</p><p>首先将文件拖入PE中查看是否加壳和位数<br>在最后一行的info信息中如果出现upx，那就代表经过了upx加壳</p><p>有针对脱壳的工具upx-5.0.2-win64 </p><p>找到upx-5.0.2-win64文件中的upx后打开终端，然后输入 upx -d 程序名称<br>这里程序名称要的是绝对地址或相对地址，当然你也可以将程序拖到终端中<br>然后会自动脱壳，如果失败，根据提示具体解决<br>当然也有反upx脱壳工具的程序，也会导致脱壳失败，这是需要手动脱壳</p><p>OEP(Original Entry Point)是程序的原始入口点的位置，EP(Entry Point)是程序的入口点，加壳之后，程序的入口点会被改动，所以有OEP，<br>需要从OEP开始脱壳，有两个指令，一个是pushad，还有popad，从pushad开始找，一直运行到结束</p><p>OEP：(Original Entry Point)，程序的原始入口点，软件加壳就是隐藏了EP， 只要我们找到程序的OEP，就可以立刻脱壳。<br>PUSHAD （压栈） 代表程序的入口点，POPAD （出栈） 代表程序的出口点，与PUSHAD相对应，一般找到这个OEP就在附近啦。</p><p>进入到程序里面后找到文件的入口<br>pushad意味着upx壳解压缩代码的入口。<br>64位程序中没有pushad，而是用几个push汇编代码替代。32位程序中存在pushad。<br>像这样的：<br>push rbx;<br>push rsi;<br>push rdi;<br>push rbp;  几个连一起的</p><p>第一就是用x32|64 找到入口：<br>点击断点 -&gt; 查找入口 -&gt; 找到之后点进去将第一行设为原始断点 EIP<br>-&gt; 之后按F8步过直到 ESP(FPU窗口) 发生变化 -&gt; 点击ESP右键找到”在内存窗口中转到” 点击<br>-&gt; 在地址窗口中将该地址右键 -&gt; 找到断点 -&gt;访问 -&gt; 2字节 -&gt; 之后便是运行会出现真正的函数窗口<br>-&gt; 之后便是用 Scylla x86 来将程序修复</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据储存</title>
    <link href="/2025/10/04/dataStorage/"/>
    <url>/2025/10/04/dataStorage/</url>
    
    <content type="html"><![CDATA[<h5 id="数据在内存中的表示方式"><a href="#数据在内存中的表示方式" class="headerlink" title="数据在内存中的表示方式"></a>数据在内存中的表示方式</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="bit-比特-位"><a href="#bit-比特-位" class="headerlink" title="bit(比特&#x2F;位)"></a>bit(比特&#x2F;位)</h5><h5 id="bit是计算机中最小的数据单位，只有两种状态开-1-关-1"><a href="#bit是计算机中最小的数据单位，只有两种状态开-1-关-1" class="headerlink" title="bit是计算机中最小的数据单位，只有两种状态开(1)关(1)"></a>bit是计算机中最小的数据单位，只有两种状态开(1)关(1)</h5><h5 id="计算机底层是数字电路，由晶体管组成，它们的工作状态-导通-截止-非常适用01"><a href="#计算机底层是数字电路，由晶体管组成，它们的工作状态-导通-截止-非常适用01" class="headerlink" title="计算机底层是数字电路，由晶体管组成，它们的工作状态(导通&#x2F;截止)非常适用01"></a>计算机底层是数字电路，由晶体管组成，它们的工作状态(导通&#x2F;截止)非常适用01</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="byte-字节"><a href="#byte-字节" class="headerlink" title="byte(字节)"></a>byte(字节)</h5><h5 id="1byte由8个bit组成，这是计算机信息处理的基本单位"><a href="#1byte由8个bit组成，这是计算机信息处理的基本单位" class="headerlink" title="1byte由8个bit组成，这是计算机信息处理的基本单位"></a>1byte由8个bit组成，这是计算机信息处理的基本单位</h5><h5 id="为什么是1byte-8bit-，-因为-1bit有两种状态则8bit，组合一起就是2-8-256"><a href="#为什么是1byte-8bit-，-因为-1bit有两种状态则8bit，组合一起就是2-8-256" class="headerlink" title="为什么是1byte&#x3D;8bit ， 因为 1bit有两种状态则8bit，组合一起就是2^8 &#x3D; 256"></a>为什么是1byte&#x3D;8bit ， 因为 1bit有两种状态则8bit，组合一起就是2^8 &#x3D; 256</h5><h5 id="这256中状态足以覆盖英文字母，数字，标点"><a href="#这256中状态足以覆盖英文字母，数字，标点" class="headerlink" title="这256中状态足以覆盖英文字母，数字，标点"></a>这256中状态足以覆盖英文字母，数字，标点</h5><h5 id="表示方式："><a href="#表示方式：" class="headerlink" title="表示方式："></a>表示方式：</h5><h5 id="二进制：-01101011"><a href="#二进制：-01101011" class="headerlink" title="二进制：  01101011"></a>二进制：  01101011</h5><h5 id="十六进制：0x6B-（这里是十六进制和二进制的转换-0110-6-1011-B）"><a href="#十六进制：0x6B-（这里是十六进制和二进制的转换-0110-6-1011-B）" class="headerlink" title="十六进制：0x6B （这里是十六进制和二进制的转换 0110 &#x3D; 6  1011&#x3D;B）"></a>十六进制：0x6B （这里是十六进制和二进制的转换 0110 &#x3D; 6  1011&#x3D;B）</h5><h5 id="十进制：-107"><a href="#十进制：-107" class="headerlink" title="十进制：  107"></a>十进制：  107</h5><h5 id="字符：-如果这个字符的值在ASCII的范围内，它可能代表一个字母-0x6B-‘k’"><a href="#字符：-如果这个字符的值在ASCII的范围内，它可能代表一个字母-0x6B-‘k’" class="headerlink" title="字符：    如果这个字符的值在ASCII的范围内，它可能代表一个字母 0x6B &#x3D; ‘k’"></a>字符：    如果这个字符的值在ASCII的范围内，它可能代表一个字母 0x6B &#x3D; ‘k’</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="程序中的所有数据-数字，字符串，密钥-在内存中有意连续的字节形式存放的"><a href="#程序中的所有数据-数字，字符串，密钥-在内存中有意连续的字节形式存放的" class="headerlink" title="程序中的所有数据(数字，字符串，密钥)在内存中有意连续的字节形式存放的"></a>程序中的所有数据(数字，字符串，密钥)在内存中有意连续的字节形式存放的</h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="字节储存顺序"><a href="#字节储存顺序" class="headerlink" title="字节储存顺序"></a>字节储存顺序</h5><h5 id="数据在储存器中的存放顺序主要分为：大端序，小端序"><a href="#数据在储存器中的存放顺序主要分为：大端序，小端序" class="headerlink" title="数据在储存器中的存放顺序主要分为：大端序，小端序"></a>数据在储存器中的存放顺序主要分为：大端序，小端序</h5><h5 id="大端序：高位字节存放低地址，低位字节存放高地址"><a href="#大端序：高位字节存放低地址，低位字节存放高地址" class="headerlink" title="大端序：高位字节存放低地址，低位字节存放高地址"></a>大端序：高位字节存放低地址，低位字节存放高地址</h5><h5 id="小端序：低位字节存放低地址，高位字节存放高地址"><a href="#小端序：低位字节存放低地址，高位字节存放高地址" class="headerlink" title="小端序：低位字节存放低地址，高位字节存放高地址"></a>小端序：低位字节存放低地址，高位字节存放高地址</h5><h5 id="一般来说，x86系列CPU的都是小端序，PC的都是大端序端序"><a href="#一般来说，x86系列CPU的都是小端序，PC的都是大端序端序" class="headerlink" title="一般来说，x86系列CPU的都是小端序，PC的都是大端序端序"></a>一般来说，x86系列CPU的都是小端序，PC的都是大端序端序</h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="-7"><a href="#-7" class="headerlink" title=""></a></h5><h5 id="-8"><a href="#-8" class="headerlink" title=""></a></h5><h5 id="-9"><a href="#-9" class="headerlink" title=""></a></h5><h5 id="-10"><a href="#-10" class="headerlink" title=""></a></h5><h5 id="-11"><a href="#-11" class="headerlink" title=""></a></h5><h5 id="-12"><a href="#-12" class="headerlink" title=""></a></h5><h5 id="-13"><a href="#-13" class="headerlink" title=""></a></h5><h5 id="-14"><a href="#-14" class="headerlink" title=""></a></h5><h5 id="-15"><a href="#-15" class="headerlink" title=""></a></h5><h5 id="-16"><a href="#-16" class="headerlink" title=""></a></h5><h5 id="-17"><a href="#-17" class="headerlink" title=""></a></h5><h5 id="-18"><a href="#-18" class="headerlink" title=""></a></h5><h5 id="-19"><a href="#-19" class="headerlink" title=""></a></h5><h5 id="-20"><a href="#-20" class="headerlink" title=""></a></h5><h5 id="-21"><a href="#-21" class="headerlink" title=""></a></h5><h5 id="-22"><a href="#-22" class="headerlink" title=""></a></h5><h5 id="-23"><a href="#-23" class="headerlink" title=""></a></h5><h5 id="-24"><a href="#-24" class="headerlink" title=""></a></h5><h5 id="-25"><a href="#-25" class="headerlink" title=""></a></h5><h5 id="-26"><a href="#-26" class="headerlink" title=""></a></h5><h5 id="-27"><a href="#-27" class="headerlink" title=""></a></h5><h5 id="-28"><a href="#-28" class="headerlink" title=""></a></h5><h5 id="-29"><a href="#-29" class="headerlink" title=""></a></h5><h5 id="-30"><a href="#-30" class="headerlink" title=""></a></h5><h5 id="-31"><a href="#-31" class="headerlink" title=""></a></h5><h5 id="-32"><a href="#-32" class="headerlink" title=""></a></h5><h5 id="-33"><a href="#-33" class="headerlink" title=""></a></h5><h5 id="-34"><a href="#-34" class="headerlink" title=""></a></h5><h5 id="-35"><a href="#-35" class="headerlink" title=""></a></h5><h5 id="-36"><a href="#-36" class="headerlink" title=""></a></h5><h5 id="-37"><a href="#-37" class="headerlink" title=""></a></h5><h5 id="-38"><a href="#-38" class="headerlink" title=""></a></h5><h5 id="-39"><a href="#-39" class="headerlink" title=""></a></h5><h5 id="-40"><a href="#-40" class="headerlink" title=""></a></h5><h5 id="-41"><a href="#-41" class="headerlink" title=""></a></h5><h5 id="-42"><a href="#-42" class="headerlink" title=""></a></h5><h5 id="-43"><a href="#-43" class="headerlink" title=""></a></h5><h5 id="-44"><a href="#-44" class="headerlink" title=""></a></h5><h5 id="-45"><a href="#-45" class="headerlink" title=""></a></h5><h5 id="-46"><a href="#-46" class="headerlink" title=""></a></h5><h5 id="-47"><a href="#-47" class="headerlink" title=""></a></h5><h5 id="-48"><a href="#-48" class="headerlink" title=""></a></h5><h5 id="-49"><a href="#-49" class="headerlink" title=""></a></h5><h5 id="-50"><a href="#-50" class="headerlink" title=""></a></h5><h5 id="-51"><a href="#-51" class="headerlink" title=""></a></h5><h5 id="-52"><a href="#-52" class="headerlink" title=""></a></h5><h5 id="-53"><a href="#-53" class="headerlink" title=""></a></h5><h5 id="-54"><a href="#-54" class="headerlink" title=""></a></h5><h5 id="-55"><a href="#-55" class="headerlink" title=""></a></h5><h5 id="-56"><a href="#-56" class="headerlink" title=""></a></h5><h5 id="-57"><a href="#-57" class="headerlink" title=""></a></h5><h5 id="-58"><a href="#-58" class="headerlink" title=""></a></h5><h5 id="-59"><a href="#-59" class="headerlink" title=""></a></h5><h5 id="-60"><a href="#-60" class="headerlink" title=""></a></h5><h5 id="-61"><a href="#-61" class="headerlink" title=""></a></h5><h5 id="-62"><a href="#-62" class="headerlink" title=""></a></h5><h5 id="-63"><a href="#-63" class="headerlink" title=""></a></h5><h5 id="-64"><a href="#-64" class="headerlink" title=""></a></h5><h5 id="-65"><a href="#-65" class="headerlink" title=""></a></h5><h5 id="-66"><a href="#-66" class="headerlink" title=""></a></h5><h5 id="-67"><a href="#-67" class="headerlink" title=""></a></h5><h5 id="-68"><a href="#-68" class="headerlink" title=""></a></h5><h5 id="-69"><a href="#-69" class="headerlink" title=""></a></h5><h5 id="-70"><a href="#-70" class="headerlink" title=""></a></h5><h5 id="-71"><a href="#-71" class="headerlink" title=""></a></h5><h5 id="-72"><a href="#-72" class="headerlink" title=""></a></h5><h5 id="-73"><a href="#-73" class="headerlink" title=""></a></h5><h5 id="-74"><a href="#-74" class="headerlink" title=""></a></h5><h5 id="-75"><a href="#-75" class="headerlink" title=""></a></h5><h5 id="-76"><a href="#-76" class="headerlink" title=""></a></h5><h5 id="-77"><a href="#-77" class="headerlink" title=""></a></h5><h5 id="-78"><a href="#-78" class="headerlink" title=""></a></h5><h5 id="-79"><a href="#-79" class="headerlink" title=""></a></h5><h5 id="-80"><a href="#-80" class="headerlink" title=""></a></h5><h5 id="-81"><a href="#-81" class="headerlink" title=""></a></h5><h5 id="-82"><a href="#-82" class="headerlink" title=""></a></h5><h5 id="-83"><a href="#-83" class="headerlink" title=""></a></h5><h5 id="-84"><a href="#-84" class="headerlink" title=""></a></h5><h5 id="-85"><a href="#-85" class="headerlink" title=""></a></h5><h5 id="-86"><a href="#-86" class="headerlink" title=""></a></h5><h5 id="-87"><a href="#-87" class="headerlink" title=""></a></h5><h5 id="-88"><a href="#-88" class="headerlink" title=""></a></h5><h5 id="-89"><a href="#-89" class="headerlink" title=""></a></h5><h5 id="-90"><a href="#-90" class="headerlink" title=""></a></h5><h5 id="-91"><a href="#-91" class="headerlink" title=""></a></h5><h5 id="-92"><a href="#-92" class="headerlink" title=""></a></h5><h5 id="-93"><a href="#-93" class="headerlink" title=""></a></h5><h5 id="-94"><a href="#-94" class="headerlink" title=""></a></h5><h5 id="-95"><a href="#-95" class="headerlink" title=""></a></h5><h5 id="-96"><a href="#-96" class="headerlink" title=""></a></h5><h5 id="-97"><a href="#-97" class="headerlink" title=""></a></h5><h5 id="-98"><a href="#-98" class="headerlink" title=""></a></h5><h5 id="-99"><a href="#-99" class="headerlink" title=""></a></h5><h5 id="-100"><a href="#-100" class="headerlink" title=""></a></h5><h5 id="-101"><a href="#-101" class="headerlink" title=""></a></h5><h5 id="-102"><a href="#-102" class="headerlink" title=""></a></h5><h5 id="-103"><a href="#-103" class="headerlink" title=""></a></h5><h5 id="-104"><a href="#-104" class="headerlink" title=""></a></h5><h5 id="-105"><a href="#-105" class="headerlink" title=""></a></h5><h5 id="-106"><a href="#-106" class="headerlink" title=""></a></h5><h5 id="-107"><a href="#-107" class="headerlink" title=""></a></h5><h5 id="-108"><a href="#-108" class="headerlink" title=""></a></h5><h5 id="-109"><a href="#-109" class="headerlink" title=""></a></h5><h5 id="-110"><a href="#-110" class="headerlink" title=""></a></h5><h5 id="-111"><a href="#-111" class="headerlink" title=""></a></h5><h5 id="-112"><a href="#-112" class="headerlink" title=""></a></h5><h5 id="-113"><a href="#-113" class="headerlink" title=""></a></h5><h5 id="-114"><a href="#-114" class="headerlink" title=""></a></h5><h5 id="-115"><a href="#-115" class="headerlink" title=""></a></h5><h5 id="-116"><a href="#-116" class="headerlink" title=""></a></h5><h5 id="-117"><a href="#-117" class="headerlink" title=""></a></h5><h5 id="-118"><a href="#-118" class="headerlink" title=""></a></h5><h5 id="-119"><a href="#-119" class="headerlink" title=""></a></h5><h5 id="-120"><a href="#-120" class="headerlink" title=""></a></h5><h5 id="-121"><a href="#-121" class="headerlink" title=""></a></h5><h5 id="-122"><a href="#-122" class="headerlink" title=""></a></h5><h5 id="-123"><a href="#-123" class="headerlink" title=""></a></h5><h5 id="-124"><a href="#-124" class="headerlink" title=""></a></h5><h5 id="-125"><a href="#-125" class="headerlink" title=""></a></h5><h5 id="-126"><a href="#-126" class="headerlink" title=""></a></h5><h5 id="-127"><a href="#-127" class="headerlink" title=""></a></h5><h5 id="-128"><a href="#-128" class="headerlink" title=""></a></h5><h5 id="-129"><a href="#-129" class="headerlink" title=""></a></h5><h5 id="-130"><a href="#-130" class="headerlink" title=""></a></h5><h5 id="-131"><a href="#-131" class="headerlink" title=""></a></h5><h5 id="-132"><a href="#-132" class="headerlink" title=""></a></h5><h5 id="-133"><a href="#-133" class="headerlink" title=""></a></h5><h5 id="-134"><a href="#-134" class="headerlink" title=""></a></h5><h5 id="-135"><a href="#-135" class="headerlink" title=""></a></h5><h5 id="-136"><a href="#-136" class="headerlink" title=""></a></h5><h5 id="-137"><a href="#-137" class="headerlink" title=""></a></h5><h5 id="-138"><a href="#-138" class="headerlink" title=""></a></h5><h5 id="-139"><a href="#-139" class="headerlink" title=""></a></h5><h5 id="-140"><a href="#-140" class="headerlink" title=""></a></h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些偏门的运算</title>
    <link href="/2025/10/04/SomeNicheOperations/"/>
    <url>/2025/10/04/SomeNicheOperations/</url>
    
    <content type="html"><![CDATA[<h5 id="模运算的逆运算："><a href="#模运算的逆运算：" class="headerlink" title="模运算的逆运算："></a><strong>模运算的逆运算：</strong></h5><p><strong>加密后 &#x3D; (原始值 + 偏移) % 模值</strong>     </p><p>**原始值 &#x3D; (加密后 - 偏移 + 模值) % 模值    &#x2F;&#x2F;**这里加上模值是因为取模可能是负数</p><p>这个式子成立的关键是     0&lt;&#x3D; 原始值 &lt;&#x3D; 模值，这是字符加密的常见场景；</p><p>当不成立时就是 **原始值 &#x3D; (加密后 - 偏移 + 模值*k) % 模值 ,**你可以自己写一下数字，模拟一下；</p><h5 id="生成随机数："><a href="#生成随机数：" class="headerlink" title="生成随机数："></a><strong>生成随机数：</strong></h5><p><strong>rand(),srand()</strong></p><p>rand_num &#x3D; rand() % num +a  这里的num是生成数的区间，a是区间的左区间</p><p>对于区间[a, b)的随机整数：(rand() % (b-a)) + a</p><p>对于区间[a, b]的随机整数：(rand() % (b-a+1)) + a</p><p>srand()函数用于设置rand()函数生成随机数时所用的种子,</p><p>当用rand而不设种子时，后面的随机数是相同的，可以理解为rand函数是根据时间轴而生成数的，</p><p>rand生成数的时间轴需要srand来更换</p><p><strong>用法：</strong></p><p>用rand 需要引入头文件stdlib</p><p>需要引入<strong>time</strong>头文件，在开头写入<strong>srand((unsigned)time(NULL));</strong> 就行</p><h4 id="使用-Python-的numpy库直接求解线性方程组"><a href="#使用-Python-的numpy库直接求解线性方程组" class="headerlink" title="使用 Python 的numpy库直接求解线性方程组"></a>使用 Python 的numpy库直接求解线性方程组</h4><p>当有解方程组是多元的时候就用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>另外一些加密算法</title>
    <link href="/2025/10/04/otherAlgorithms/"/>
    <url>/2025/10/04/otherAlgorithms/</url>
    
    <content type="html"><![CDATA[<h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h2><p>凯撒加密是一种简单的替换加密技术，将明文中的所有字母全部偏移key个单位来进行加密。</p><h3 id="加密实现"><a href="#加密实现" class="headerlink" title="加密实现"></a>加密实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义字母表模型</span><br>model1 = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  <span class="hljs-comment"># 小写字母</span><br>model2 = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>  <span class="hljs-comment"># 大写字母</span><br><br><span class="hljs-comment"># 明文和密钥</span><br>plaintext = <span class="hljs-string">&quot;flag&#123;i_LOVE_Reverse&#125;&quot;</span><br>key = <span class="hljs-number">11</span><br><br><span class="hljs-comment"># 加密过程</span><br>encrypted = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> plaintext:<br>    <span class="hljs-keyword">if</span> s.islower():<br>        n = model1.find(s)<br>        s = model1[(n + key) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 取模运算防止索引越界</span><br>    <span class="hljs-keyword">elif</span> s.isupper():<br>        n = model2.find(s)  <span class="hljs-comment"># 修复bug：大写字母应使用model2</span><br>        s = model2[(n + key) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 修复bug：大写字母应使用model2</span><br>    encrypted += s<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;加密结果：&quot;</span>, encrypted)  <span class="hljs-comment"># 输出：qwlr&#123;t_WZGP_Cpgpcdp&#125;</span><br></code></pre></td></tr></table></figure><h3 id="解密实现"><a href="#解密实现" class="headerlink" title="解密实现"></a>解密实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 解密过程（尝试所有可能的密钥）</span><br>ciphertext = <span class="hljs-string">&quot;qwlr&#123;t_WZGP_Cpgpcdp&#125;&quot;</span><br><br><span class="hljs-keyword">for</span> key_try <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">27</span>):<br>    decrypted = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> ciphertext:<br>        <span class="hljs-keyword">if</span> s.islower():<br>            n = model1.find(s)<br>            s = model1[(n - key_try) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 反向偏移</span><br>        <span class="hljs-keyword">elif</span> s.isupper():<br>            n = model2.find(s)<br>            s = model2[(n - key_try) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 反向偏移</span><br>        decrypted += s<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;密钥 <span class="hljs-subst">&#123;key_try&#125;</span>: <span class="hljs-subst">&#123;decrypted&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 当key_try=11时，将得到原始明文</span><br></code></pre></td></tr></table></figure><h2 id="ROT13加密"><a href="#ROT13加密" class="headerlink" title="ROT13加密"></a>ROT13加密</h2><p>ROT13是凯撒加密的一个特例，固定将字母向后移动13位。由于字母表共有26个字母，对同一文本应用两次ROT13即可恢复原始文本。非英文字母的字符（如数字、符号）则保持不变。</p><h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ROT13加密函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rot13</span>(<span class="hljs-params">flag</span>) &#123;<br>    <span class="hljs-keyword">return</span> flag.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[a-zA-Z]/g</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-comment">// 将字符转换为Unicode编码并加13</span><br>        <span class="hljs-comment">// 如果结果超过字母范围（大写字母90，小写字母122），则减26回到范围内</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>((c &lt;= <span class="hljs-string">&quot;Z&quot;</span> ? <span class="hljs-number">90</span> : <span class="hljs-number">122</span>) &gt;= (c = c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)+ <span class="hljs-number">13</span>) ? c : c - <span class="hljs-number">26</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术解析"><a href="#技术解析" class="headerlink" title="技术解析"></a>技术解析</h3><ul><li><code>String.fromCharCode()</code> 函数：将Unicode编码转换为对应的字符</li><li><code>charCodeAt()</code> 函数：将字符转换为对应的Unicode编码</li><li><code>(c &lt;= &quot;Z&quot; ? 90 : 122)</code>：判断字符是大写还是小写，分别获取字母表边界值</li><li><code>(c = c.charCodeAt(0)+ 13)</code>：将字符转换为Unicode编码并加13</li><li><code>(c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0)+ 13)</code>：判断是否超出字母范围，超出则需要回滚到字母表开始位置</li><li>由于字母共有26个，ROT13的特性使得加13和减13效果相同，加密和解密可以使用同一个函数</li></ul><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>前提了解 欧拉函数<br>欧拉函数是小于n的正整数中与n互质的数目 ， 那n为质数的话则 (n)为 n-1<br>如果一个数n为两个质数p,q的积，则改欧拉函数为(n) &#x3D; (q-1)*(p-1)</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.开始要先选取两个互质的数p 、q,这里数要很大<br>    (1)p,q一般为512b，使n到1024b,重要的运用时p,q为1024b,使n达到2048b<br>    (2)p,q应为强素数,且p,q差要大<br>    (3)(p-1)和(q-1)的最大公因数最小<br>2.找到p,q后便计算(n),n,将n公开<br>3.随机找一个正整数e，1 &lt; e &lt; (n) ,且 e和(n)互质<br>4.根据e和(n)找到一个整数d为模反元素，模反元素就是 ed % (n) &#x3D; 1<br>5.公钥 k &#x3D; &lt;e,n&gt; ; 私钥：k &#x3D; &lt;d,p,q,(n)&gt;<br>6.加密算法：C &#x3D; M(e) mod n  这里括号是次方的意思<br>7.解密运算：M &#x3D; C(d) mod n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里给一个题，是buuctf里的rsa</span><br><span class="hljs-comment">#打开key.enc的文件是</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#-----BEGIN PUBLIC KEY-----</span><br><span class="hljs-comment"># MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+</span><br><span class="hljs-comment"># /AvKr1rzQczdAgMBAAE=</span><br><span class="hljs-comment">#-----END PUBLIC KEY-----</span><br><span class="hljs-comment">#首先判断一下，通常这种 PEM 的格式里面是Base64编码的DER数据</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes, bytes_to_long<br>key_base = <span class="hljs-string">&quot;MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+/AvKr1rzQczdAgMBAAE=&quot;</span><br><br>key_data = base64.b64decode(key_base) <span class="hljs-comment">#因为这里的解码是二进制数据，不是文本数据，所以不用decode</span><br><span class="hljs-comment"># 使用专门的 RSA 库解析二进制结构</span><br>public_key = RSA.import_key(key_data) <span class="hljs-comment">#这时public_key是一个对象，包含n和e</span><br>n = public_key.n    <span class="hljs-comment">#86934482296048119190666062003494800588905656017203025617216654058378322103517</span><br>e = public_key.e  <span class="hljs-comment">#65537</span><br><span class="hljs-comment">#n有了，那就是求p、q了，有专门的网站 https://factordb.com/</span><br>p = <span class="hljs-number">285960468890451637935629440372639283459</span><br>q = <span class="hljs-number">304008741604601924494328155975272418463</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><span class="hljs-comment">#这里你可以用 gmpy2 求模反元素 d ，我这里用的是 py3.8 的 pow来求得</span><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br><span class="hljs-comment">#目前根据 M = C(d) mod n , 只需要将flag.enc文件读取便可以求解,因为目前猜测只有flag.enc藏有密文，而且，他已经提示很明显了flag.enc</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    text = f.read()  <span class="hljs-comment">#这里把数据拿到了，赋值给text，这里text是字节数据</span><br><br>flag = bytes_to_long(text)  <span class="hljs-comment">#转换为整数用于计算</span><br>flag_long = <span class="hljs-built_in">pow</span>(flag,d,n)    <span class="hljs-comment">#这里是整数形式，需要转换为byte</span><br>flag = long_to_bytes(flag_long)<br><span class="hljs-built_in">print</span>(flag) <br><span class="hljs-comment">#b&#x27;\x02\x9d &#123;zR\x1e\x08\xe4\xe6\x18\x06\x00flag&#123;decrypt_256&#125;\n&#x27;</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
