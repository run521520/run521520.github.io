<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>angr</title>
    <link href="/2025/10/20/08_angr/"/>
    <url>/2025/10/20/08_angr/</url>
    
    <content type="html"><![CDATA[<p>学习视频是B站的<br>作者是:mr_m0nst3r<br><a href="https://www.bilibili.com/video/BV167411o7WK/?vd_source=fd5cdb6d7f1c081069afc1d62787fbf8">链接</a><br><a href="https://github.com/jakespringer/angr_ctf">学习资源</a></p><p>这个博主写的也不错,可以看一下<a href="https://starrysky1004.github.io/2024/12/17/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/#toc-heading-16">starrysky</a></p><p>安装的话就不说了，因为博主也是看着网上的安装的。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>什么是符号执行：<br>符号执行 （Symbolic Execution）是一种程序分析技术。可以通过分析程序来得到让特定代码区域执行的输入。<br>使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。<br>在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。<br>符号模拟技术（symbolic simulation）则把类似的思想用于硬件分析。<br>符号计算（Symbolic computation）则用于数学表达式分析。我理解为更厉害的爆破。<br><a href="https://blog.csdn.net/weixin_52369224/article/details/121319151">原文链接</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用angr分析的大致流程：</p><ol><li>导入angr</li><li>导入二进制文件</li><li>创建程序入口点的状态(state)</li><li>将要求解的变量符号化,定义符号变量并与二进制文件相联系</li><li>建立simgr,用于管理state</li><li>通过.active的变化来找到满足我们要求的目标状态</li><li>求解程序执行行到state时,符号化变量所需的目标状态</li><li>解出约束条件,获取目标状态的数值</li></ol><h3 id="1-创建project对象"><a href="#1-创建project对象" class="headerlink" title="1. 创建project对象"></a>1. 创建project对象</h3><p>因为angr是一个基于符号执行和模拟执行的二进制框架,所以运行文件的二进制,你必须要有。<br>载入二进制文件使用<code>angr.Project函数</code>,它的第一个参数是载入文件的路径,后面还有其它参数<br>我没学。<br><code>p = angr.Project(&#39;/text&#39;)</code><br>project只是加载二进制文件，实际是对simstate对象操作<br>simstate对象是程序的状态，包含运行时的一切信息，例如寄存器、内存值、文件系统、符号变量。</p><hr><h3 id="2-设置state"><a href="#2-设置state" class="headerlink" title="2. 设置state"></a>2. 设置state</h3><p>创建项目之后,需要一个工厂来解决问题,创建一个状态，默认是程序的入口地址,<br>这个状态保存着程序运行到某一阶段的信息,且可以通过修改这一状态进而修改上下文的信息。</p><p><code>state = p.factory.entry_state()</code><br>也可以指定一个地址作为入口地址<br><code>state = p.factory.entry_state(addr=0x110110)</code><br>比如这里就指定0x110110作为入口地址,一般地址设为加密的函数入口。</p><ul><li><p>entry_state:做一些初始化工作，然后在程序的入口停下。<br>在创建完entry_state，之后就可以通过这个state对象，获取或者修改此时程序的运行状态。</p></li><li><p>state对象一般是符号执行开始前创建,用来初始化一些数据,或者是在路劲探索结束后,返回一个state<br>对象供用户提取需要的值,或进行约束求解.<br>创建完之后便是寻找路劲。程序当前的状态有多种表示。<br>**step()**表示向下执行一个block(42bytes)，**step()**函数产生active状态，<br>表示该分支在执行中。<br>**run()**表示运行到结束，**run()**函数产生deadended状态，表示分支结束。<br>**explore()**可以对地址进行限制以减少符号执行遍历的路径。**explore()**产生found状态<br>表示探索的结果等等。</p></li></ul><hr><h3 id="3-设置Simulation-Managers，进行路径探索的对象"><a href="#3-设置Simulation-Managers，进行路径探索的对象" class="headerlink" title="3. 设置Simulation Managers，进行路径探索的对象"></a>3. 设置Simulation Managers，进行路径探索的对象</h3><p>这个对象用于具体的路径探索<br><code>sm = p.factory.simulation_manager(state)</code><br>指定我们想要走到的位置：（使用explore执行模拟器，find和avoid用来作为约束条件）<br><code>res = sm.explore(find = 0x4005fb, avoid = 0x400607)</code><br>执行len(res.found)输出为1，可以知道found了一个结果,我们把找到的这个结果输出：<br><code>res.found[0].posix.dumps(0).strip(&quot;\x00&quot;)</code></p><hr><p>所以大致流程代码就是上面的了。</p><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><h3 id="简单的一个模板"><a href="#简单的一个模板" class="headerlink" title="简单的一个模板:"></a><strong>简单的一个模板:</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<span class="hljs-comment">#导angr包</span><br><br>p = angr.Project(<span class="hljs-string">&#x27;/root&#x27;</span>)   <span class="hljs-comment"># 创建项目,引入路劲,可以在路劲后面加上 auto_load_libs=False 关闭自动加载库提高性能</span><br>state = p.factory.entry_state() <span class="hljs-comment">#建工厂,就是初始化状态</span><br><br>sm = p.factory.simulation_manager(state)  <span class="hljs-comment">#创建模拟管理器</span><br>sm.explore(find=<span class="hljs-number">0x110110</span>)<span class="hljs-comment">#探索路劲,find是成功分支地址,avoid是失败的地址</span><br><br>st = sm.found[<span class="hljs-number">0</span>]<br><br><span class="hljs-built_in">print</span>(st.posix.dumps(<span class="hljs-number">0</span>))<br><br></code></pre></td></tr></table></figure><p>当程序中出现多个 <code>Try again</code> 和 <code>Good job</code>,就不能再添目标地址了,<br>因为explore发现第一个成功就没了,所以针对这种情况,将这两种情况判断写<br>成函数作为<code>find</code>和<code>avoid</code>的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> angr<br>project = angr.Project(<span class="hljs-string">&#x27;./text&#x27;</span>)<br>simgr = project.factory.simulation_manager()  <span class="hljs-comment">#这是允许的可以一步到位</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Good&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Try&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find=right, avoid=wrong)<br><br><span class="hljs-keyword">if</span> simgr.found:<br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(solution_state.posix.dumps(<span class="hljs-number">0</span>))<br><br></code></pre></td></tr></table></figure><h3 id="绕过输入-操控寄存器"><a href="#绕过输入-操控寄存器" class="headerlink" title="绕过输入,操控寄存器"></a>绕过输入,操控寄存器</h3><p>就是angr的输入格式不是很好,所以为了不出现问题,不从输入入手,<br>因为输入的数据是存在寄存器中然后传递给栈,所以找到存储的寄存器就行了<br>从传递寄存器参数给栈的位置开始执行,避开输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>//输入数据<br><br>.text:08048937                 mov     ecx, [ebp+var_18]<br>.text:0804893A                 mov     eax, ecx<br>.text:0804893C                 mov     ecx, [ebp+var_14]<br>.text:0804893F                 mov     ebx, ecx<br>.text:08048941                 mov     ecx, [ebp+var_10]<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>//传递给栈<br><br>.text:0804897B                 call    get_user_input<br>.text:08048980                 mov     [ebp+var_14], eax<br>.text:08048983                 mov     [ebp+var_10], ebx<br>.text:08048986                 mov     [ebp+var_C], edx<br><br></code></pre></td></tr></table></figure><p>这里讲一下,一些相关的函数(这里是按照顺序写的):</p><ul><li><p>entry_state() 从程序入口开始执行<br><code>entry_state = project.factory.entry_state()</code><br><code>project</code>是引入文件的设置的变量名。</p></li><li><p>blank_state() 从特殊位置开始<br><code>initial_state = project.factory.blank_state(addr=0x8048000)</code><br>就是用于绕过某些函数,和步骤之类的。</p></li><li><p>claripy.BVS(name,bit) 函数 用于创建位向量符号变量 就是一个变量<br>第一个参数变量名,第二个是字节数多少位。<br><code>arg1 = claripy.BVS(&#39;arg1&#39;, 32)</code></p></li><li><p>state.regs 后面根cpu寄存器,作用是访问和设置寄存器的值<br>支持的寄存器: <code>eax, ebx, ecx, edx, esi, edi, esp, ebp, eip等</code><br>主要用于符号化寄存器输入,模拟函数参数传递。<br>设置寄存器变量：<code>initial_state.regs.eax = arg1</code></p></li><li><p>simgr &#x3D; simulation_manager 模拟管理器<br>就是我们已经创建好了变量寄存器符号后,需要对它进行模拟(就是爆破的意思)<br>就是用 simgr来实现的 <code>simgr = simulation_manager</code>意思是说 它们两个写<br>哪一个都行,在要求较为准确的文档,或其它中是  <code>simulation_manager</code>，但是写脚本<br>之类的不严谨的时候 常用 <code>simgr</code>因为前者容易写错,后者好记。</p></li></ul><p><code>simgr = project.factory.simulation_manager(initial_state)</code></p><ul><li>simgr.explore(find,avoid) 自动探索执行路线，寻找目标状态<br>find和avoid的参数可以是目标地址,同时也可以是函数,当程序中成功后的提示<br>只调用一次时便可使用<code>目标地址</code>反而就用函数,为什么呢?我们的<code>目标地址</code>其实就是<br>成功的提示,当提示被调用多次时,那怎么办,所以用函数自定义来区分到底哪一个是正确的。</li></ul><p><code>目标地址</code>很好写,找到函数地址填上去就行了。<br><code>函数定义</code>下面就是一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#假设成功的提示有 Good 失败的有 Try</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Good&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Try&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure><ol><li><code>state.posix</code> 访问POSIX相关的抽象</li><li><code>dumps(num)</code> <ul><li>num &#x3D; 0 代表输入,就是flag</li><li>num &#x3D; 1 代表输出,就是提示</li><li>num &#x3D; 2 标准错误</li></ul></li><li><code>b&#39;Good&#39; in ...</code> 则是检查输出中是否含有字符串’Good’</li></ol><ul><li>simgr.found 存储成功的列表<br>专门来存储成功的信息的,我们从中取第一个信息,就是flag<br><code>solution = simgr.found[0]</code> 这时<code>solution</code>就包含flag了<br>正常的输入就直接打印了,但是如果不正常就是输入是十六十六进制的,需要转换一下</li></ul><p>从上文中我们模拟了一个 <code>eax</code> 寄存器的变量 <code>arg1</code> 所以要从 <code>solution</code>中取出来<br>用到了<code>solver.eval()</code></p><ul><li><code>solver.eval()</code> 求解符号表达式在当前状态下的具体值<br><code>arg = solution.solver.eval(arg1)</code><br><code>print(hex(arg))</code><br>这样子就行了</li></ul><hr><p>有一个练习题<br><a href="https://github.com/jakespringer/angr_ctf/blob/master/dist/">03_angr_symbolic_registers</a></p><p>脚本是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br>project = angr.Project(<span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span>)<br>initial = project.factory.blank_state(addr=<span class="hljs-number">0x8048980</span>)<br><br>arg1 = claripy.BVS(<span class="hljs-string">&#x27;arg1&#x27;</span>, <span class="hljs-number">32</span>)<br>arg2 = claripy.BVS(<span class="hljs-string">&#x27;arg2&#x27;</span>, <span class="hljs-number">32</span>)<br>arg3 = claripy.BVS(<span class="hljs-string">&#x27;arg3&#x27;</span>, <span class="hljs-number">32</span>)<br><br>initial.regs.eax = arg1<br>initial.regs.ebx = arg2<br>initial.regs.edx = arg3<br><br>simgr = project.factory.simgr(initial)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Good&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Try&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find=right, avoid=wrong)<br><br><span class="hljs-keyword">if</span> simgr.found:<br>    solution = simgr.found[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(solution.solver.<span class="hljs-built_in">eval</span>(arg1)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(solution.solver.<span class="hljs-built_in">eval</span>(arg2)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(solution.solver.<span class="hljs-built_in">eval</span>(arg3)))<br><span class="hljs-comment">#0xb9ffd04e 0xccf63fe8 0x8fd4d959</span><br><br><br></code></pre></td></tr></table></figure><h3 id="绕过输入，操控栈"><a href="#绕过输入，操控栈" class="headerlink" title="绕过输入，操控栈"></a>绕过输入，操控栈</h3><p>就是我们还是和上面类似的情况，但是不能直接使用<strong>regs</strong>也就是说不能直接创建寄存器来符号化了。但是可以通过计算构造 <strong>esp</strong> 和 <strong>ebp</strong> 在合适的位置<strong>stack_push</strong>来入栈。<br>我们学汇编的时候都知道在进入一个函数的时候应该有以下的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">push    ebp<br>mov     ebp , esp<br>mov     esp , num    <br><br>//先把栈底ebp入栈，因为此时ebp还保存着上个函数的状态，先存着，然后就是创建一个新的&#x27;栈&#x27;，接着在栈顶开辟空间。<br></code></pre></td></tr></table></figure><p>所以虽然不可以直接创建寄存器和直接操作，但是可以将数据入栈来操作符号化。<br>这里的入栈是<code>state.stack_push()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br>project = angr.Project(<span class="hljs-string">&#x27;./04_angr_symbolic_stack&#x27;</span>)<br>initial_state = project.factory.blank_state(addr=<span class="hljs-number">0x8048697</span>)<br><br>arg1 = claripy.BVS(<span class="hljs-string">&#x27;arg1&#x27;</span>, <span class="hljs-number">32</span>)<br>arg2 = claripy.BVS(<span class="hljs-string">&#x27;arg2&#x27;</span>, <span class="hljs-number">32</span>)<br><br>initial_state.regs.esp = initial_state.regs.ebp<br>initial_state.regs.esp -= <span class="hljs-number">8</span><br><br>initial_state.stack_push(arg1)<br>initial_state.stack_push(arg2)<br><br>simgr = project.factory.simulation_manager(initial_state)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Good&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Try&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find=right, avoid=wrong)<br><br><span class="hljs-keyword">if</span> simgr.found:<br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg1))<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg2))<br>    <br><span class="hljs-comment">#1704280884</span><br><span class="hljs-comment">#2382341151</span><br></code></pre></td></tr></table></figure><h3 id="绕过输入，操控全局变量"><a href="#绕过输入，操控全局变量" class="headerlink" title="绕过输入，操控全局变量"></a>绕过输入，操控全局变量</h3><p>这这应该很好判断了，当你看到接收的变量是全局变量的时候就可以用了。<br>用到一个函数 <code>state.memory.store(地址, 变量)</code>,<br><code>cast_to=bytes</code> 意思是按字节类型输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br>project = angr.Project(<span class="hljs-string">&#x27;./05_angr_symbolic_memory&#x27;</span>)<br>initial_state = project.factory.blank_state(addr=<span class="hljs-number">0x8048601</span>)<br><br>arg1 = claripy.BVS(<span class="hljs-string">&#x27;arg1&#x27;</span>, <span class="hljs-number">64</span>)<br>arg2 = claripy.BVS(<span class="hljs-string">&#x27;arg2&#x27;</span>, <span class="hljs-number">64</span>)<br>arg3 = claripy.BVS(<span class="hljs-string">&#x27;arg3&#x27;</span>, <span class="hljs-number">64</span>)<br>arg4 = claripy.BVS(<span class="hljs-string">&#x27;arg4&#x27;</span>, <span class="hljs-number">64</span>)<br>addr = <span class="hljs-number">0xA1BA1C0</span> <br><br>initial_state.memory.store(addr, arg1)<br>initial_state.memory.store(addr + <span class="hljs-number">0x8</span>, arg2)<br>initial_state.memory.store(addr + <span class="hljs-number">0x10</span>, arg3)<br>initial_state.memory.store(addr + <span class="hljs-number">0x18</span>, arg4)<br><br>simgr = project.factory.simulation_manager(initial_state)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Good&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;Try&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find=right, avoid=wrong)<br><br><span class="hljs-keyword">if</span> simgr.found:<br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg1, cast_to=<span class="hljs-built_in">bytes</span>))<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg2, cast_to=<span class="hljs-built_in">bytes</span>))<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg3, cast_to=<span class="hljs-built_in">bytes</span>))<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(arg4, cast_to=<span class="hljs-built_in">bytes</span>))<br><span class="hljs-comment">#b&#x27;NAXTHGNR&#x27;</span><br><span class="hljs-comment">#b&#x27;JVSFTPWE&#x27;</span><br><span class="hljs-comment">#b&#x27;LMGAUHWC&#x27;</span><br><span class="hljs-comment">#b&#x27;XMDCPALU&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="怎么判断是：寄存器、栈、全局变量"><a href="#怎么判断是：寄存器、栈、全局变量" class="headerlink" title="怎么判断是：寄存器、栈、全局变量"></a>怎么判断是：寄存器、栈、全局变量</h3><p>开始的时候我也是感觉不太好分辨，查了些资料有点头绪了。</p><ol><li>当输入的值直接给寄存器并用寄存器操作的时候就是用<strong>寄存器模板</strong>，比如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0804891E                 lea     ecx, [ebp+var_10]<br>.text:08048921                 push    ecx<br>.text:08048922                 lea     ecx, [ebp+var_14]<br>.text:08048925                 push    ecx<br>.text:08048926                 lea     ecx, [ebp+var_18]<br>.text:08048929                 push    ecx<br>.text:0804892A                 push    offset aXXX     ; &quot;%x %x %x&quot;<br>.text:0804892F                 call    ___isoc99_scanf<br>.text:08048934                 add     esp, 10h<br>.text:08048937                 mov     ecx, [ebp+var_18]<br>.text:0804893A                 mov     eax, ecx<br>.text:0804893C                 mov     ecx, [ebp+var_14]<br>.text:0804893F                 mov     ebx, ecx<br>.text:08048941                 mov     ecx, [ebp+var_10]<br>.text:08048944                 mov     edx, ecx<br>.text:08048946                 nop<br></code></pre></td></tr></table></figure><p>可以好好看看先压入三个寄存器用来储存输入的值，在输入后又把值赋值给寄存器，看一下这里并没有把寄存器压入到栈中，这就是直接存储给寄存器。</p><ol start="2"><li><p>讲一下<code>scanf</code>函数的储存，<code>scanf</code>输入的值刚开始是在栈上的，但是看上面，虽然开始是在栈上的，但是立即储存到寄存器中了，并且后续都是用寄存器计算。</p></li><li><p>当输入的值不是直接给寄存器，而是一直存储在栈中的就用<strong>栈模板</strong>，比如：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0804867F                 sub     esp, 4<br>.text:08048682                 lea     eax, [ebp+var_10]<br>.text:08048685                 push    eax<br>.text:08048686                 lea     eax, [ebp+var_C]<br>.text:08048689                 push    eax<br>.text:0804868A                 push    offset aUU      ; &quot;%u %u&quot;<br>.text:0804868F                 call    ___isoc99_scanf<br>.text:08048694                 add     esp, 10h<br>.text:08048697                 mov     eax, [ebp+var_C]<br>.text:0804869A                 sub     esp, 0Ch<br>.text:0804869D                 push    eax<br>.text:0804869E                 call    complex_function0<br>.text:080486A3                 add     esp, 10h<br>.text:080486A6                 mov     [ebp+var_C], eax<br>.text:080486A9                 mov     eax, [ebp+var_10]<br>.text:080486AC                 sub     esp, 0Ch<br>.text:080486AF                 push    eax<br>.text:080486B0                 call    complex_function1<br></code></pre></td></tr></table></figure><p>明显可以看到虽然在输入后把<code>[ebp+var_C]</code>的值给了<code>eax</code>并把寄存器押入到栈中了，这是因为其他函数在调用时，方便可以从栈中取出来使用，其次在后续中并没有用<code>eax</code>来取代<code>[ebp+var_C]</code>，也就是说值一直都在栈中，思想不就是用栈来操作吗。</p><ol start="4"><li><strong>全局变量</strong>这个比较好判断，就是看接收的值是不是<strong>全局变量</strong>就行了。</li></ol><hr><pre><code class="hljs">情况                     方法                            要点      </code></pre><hr><p>返回值&#x2F;直接计算                    寄存器                        <code>regs.eax = arg1</code></p><hr><p>函数参数&#x2F;一直用内存计算       栈                              <code>stack_push(arg1)</code></p><hr><p>全局变量                               内存                            <code>memory.store(addres,name)</code></p><hr><h3 id="操控动态内存问题"><a href="#操控动态内存问题" class="headerlink" title="操控动态内存问题"></a>操控动态内存问题</h3><p>大意就是在输入的变量的内存为<code>malloc</code>动态分配的时候，程序静态的时候它是在堆栈中找不到的，只有在动态运行或调试的时候才会分配，其次分配的内存是不固定的，所以我们可以给他一个内存，然后就可以操作了，这里给的内存是用不到的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">内存地址空间：<br>0x00110110: 代码段 (text)<br>0x00220220: 数据段/BSS段 (存储全局变量)<br>0x00330330: 堆空间 (malloc分配在这里)<br></code></pre></td></tr></table></figure><p>其次在写脚本的时候，要在创建好<strong>门口</strong>的时候就创建变量的内存空间<br>就是在<code>malloc</code>之后，<code>scanf</code>之前开始执行<br><code>endness</code>设置端序</p><ul><li><code>endness = LE</code>小端序</li><li><code>endness = BE</code>大端序</li><li><code>endness = ME</code>中间序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br>p = angr.Project(<span class="hljs-string">&#x27;./06_angr_symbolic_dynamic_memory&#x27;</span>)<br>init = p.factory.blank_state(addr=<span class="hljs-number">0x8048699</span>)<br><span class="hljs-comment"># 创建符号变量</span><br>arg1 = claripy.BVS(<span class="hljs-string">&#x27;arg1&#x27;</span>,<span class="hljs-number">64</span>)<br>arg2 = claripy.BVS(<span class="hljs-string">&#x27;arg2&#x27;</span>,<span class="hljs-number">64</span>)<br><span class="hljs-comment"># 设置BSS段地址：储存堆指针的全局变量位置</span><br>add1 = <span class="hljs-number">0xABCC8A4</span>   <span class="hljs-comment"># buffer1指针本身的地址</span><br>add2 = <span class="hljs-number">0xABCC8AC</span>   <span class="hljs-comment"># buffer2指针本身的地址</span><br><span class="hljs-comment"># 自定义堆地址 不和程序原本的地址冲突就行</span><br>heap_ptr1 = <span class="hljs-number">0x12340</span>   <span class="hljs-comment"># 创建 buffer1指向这里的内存</span><br>heap_ptr2 = <span class="hljs-number">0x12350</span>   <span class="hljs-comment"># 创建 buffer2指向这里的内存</span><br><span class="hljs-comment"># 定义完后便是设置BSS段的指针值</span><br><span class="hljs-comment"># 表示 buffer1 指向 0x12340 ， 其次这里的 endness=&quot;LE&quot;告诉python这是以什么方式储存的,然后便是将符号变量的值存到内存中</span><br>init.memory.store(add1,heap_ptr1,endness=<span class="hljs-string">&quot;LE&quot;</span>)<br>init.memory.store(add2,heap_ptr2,endness=<span class="hljs-string">&quot;LE&quot;</span>)<br>init.memory.store(heap_ptr1,add1)<br>init.memory.store(heap_ptr2,add2)<br><span class="hljs-comment"># 然后便是创建符号管理器</span><br>simgr = p.factory.simgr(init)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>():<br>...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrong</span>():<br>...<br>simgr.explore(find=right,avoid=wrong)<br><br><span class="hljs-keyword">if</span> simgr.found:<br>s = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(s.solver.<span class="hljs-built_in">eval</span>(arg1,cast_to=<span class="hljs-built_in">bytes</span>))<br><span class="hljs-built_in">print</span>(s.solver.<span class="hljs-built_in">eval</span>(arg2,cast_to=<span class="hljs-built_in">bytes</span>))<br><br></code></pre></td></tr></table></figure><p>执行后的内存大概是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">BSS段 (全局变量区):<br>地址 0xABCC8A4: 0x00012340  ← 我们说buffer1指向0x12340<br>地址 0xABCC8AC: 0x00012350  ← 我们说buffer2指向0x12350<br><br>&quot;堆&quot;区域 (我们伪造的):<br>地址 0x12340: 符号数据arg1  ← 实际存储第一个输入的地方<br>地址 0x12350: 符号数据arg2  ← 实际存储第二个输入的地方<br></code></pre></td></tr></table></figure><table><thead><tr><th>题型</th><th>数据在哪</th><th>解决方法</th></tr></thead><tbody><tr><td>寄存器</td><td>寄存器中</td><td><code>regs.eax = 符号</code></td></tr><tr><td>栈参数</td><td>栈空间中</td><td><code>stack_push(符号)</code></td></tr><tr><td>静态内存</td><td>固定地址</td><td><code>store(固定地址, 符号)</code></td></tr><tr><td>动态内存</td><td>指针→堆</td><td><code>store(指针地址, 堆地址)</code> + <code>store(堆地址, 符号)</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>angr</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些做题的经验或心得</title>
    <link href="/2025/10/17/07_mybook/"/>
    <url>/2025/10/17/07_mybook/</url>
    
    <content type="html"><![CDATA[<h2 id="打印输出方式"><a href="#打印输出方式" class="headerlink" title="打印输出方式"></a>打印输出方式</h2><p>在最后一步输出flag,可能会遇到的问题,博主之前在做buuctf平台上的**[GWCTF 2019]xxor**<br>的时候就被坑了,它那个tea解密后只有三个字节,大端,博主是用c一个一个读取的,然后直接打印<br>字符串的,所以它是空的,以至于我花了一个小时找wp,找我的问题但是没找到,<br>在随便查看的时候就把解密的数组打印了,然后我才知道它是三个字节,<br>不是四个,所以把它一个一个打印就行了,但是我要是一开始就遍历打印的话可能就没问题把,<br>所以有时候你的flag是求对了,但是储存在数组中可能有<code>0x00</code>这时候<code>printf</code>会停到那里,<br>所以可以的话还是用循环遍历打印。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GMP中的一些函数</title>
    <link href="/2025/10/14/06_GMP/"/>
    <url>/2025/10/14/06_GMP/</url>
    
    <content type="html"><![CDATA[<p>讲一下GMP中的函数,和c语言中的函数</p><h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h2 id="gmpz-init-set-str"><a href="#gmpz-init-set-str" class="headerlink" title="__gmpz_init_set_str"></a>__gmpz_init_set_str</h2><p>用于初始化大整数并为其设置字符串表示的值。<br><code>int __gmpz_init_set_str (mpz_t rop, const char *str, int base)</code></p><ul><li>rop: 要初始化的<strong>mpz_t</strong>类型的大整数变量</li><li>str: 包含数字和字符串(可包含可选符号)</li><li>base: 数值的进制基数(2-62,或0表示自动检测)</li><li>成功返回0,失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;gmp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">mpz_t</span> big_num;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;123456789012345678901234567890&quot;</span>;<br>    <span class="hljs-comment">// 初始化大整数并设置十进制字符串值</span><br>    <span class="hljs-keyword">if</span> (__gmpz_init_set_str(big_num, str, <span class="hljs-number">10</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 使用 big_num...</span><br>        gmp_printf(<span class="hljs-string">&quot;Value: %Zd\n&quot;</span>, big_num);<br>    &#125;<br>    <br>    mpz_clear(big_num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//这在编译器可能运行不了,意思就是记住 big_num = 123456789012345678901234567890</span><br><span class="hljs-comment">//</span><br><br></code></pre></td></tr></table></figure><h3 id="相关的函数："><a href="#相关的函数：" class="headerlink" title="相关的函数："></a>相关的函数：</h3><ul><li><code>__gmpz_init</code> 仅初始化大整数</li><li><code>__gmpz_set_str</code> 为已初始化的大整数设置值</li><li><code>__gmpz_clear</code> 清理大整数内存</li></ul><hr><h2 id="gmpz-powm"><a href="#gmpz-powm" class="headerlink" title="__gmpz_powm"></a>__gmpz_powm</h2><p>是 GMP库中用于<strong>模幂运算</strong> 的函数</p><p><code>void __gmpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)</code></p><ul><li>rop:结果变量,储存计算结果</li><li>base:底数</li><li>exp:指数</li><li>mod:模数<br><strong><code>rop = base^exp mod mod</code></strong></li></ul><p>运用在:RSA、ElGamal、DSA等公钥密码,Diffie-Hellman密钥交换,数字签名</p><h2 id="gmpz-cmp"><a href="#gmpz-cmp" class="headerlink" title="__gmpz_cmp"></a>__gmpz_cmp</h2><p>GMP库中用于比较两个大整数的函数<br><code>int __gmpz_cmp (const mpz_t op1, const mpz_t op2)</code></p><p>如果 op1 &#x2F;&gt; op2 为正数<br>如果 op1 &#x3D;&#x3D; op2 为0<br>如果 op1 &#x2F;&lt; op2 为负数</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="printf-打印"><a href="#printf-打印" class="headerlink" title="printf 打印"></a>printf 打印</h2><p>printf 是c语言中的格式化输出函数,支持多种类型和格式化。</p><h2 id="scanf-输入"><a href="#scanf-输入" class="headerlink" title="scanf 输入"></a>scanf 输入</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程权威指南上</title>
    <link href="/2025/10/10/reverse_books/"/>
    <url>/2025/10/10/reverse_books/</url>
    
    <content type="html"><![CDATA[<h2 id="1-CPU简介"><a href="#1-CPU简介" class="headerlink" title="1. CPU简介"></a>1. CPU简介</h2><p>CPU是执行机器码的硬件单元，可以叫它中央处理器，相当于人的大脑，处理各种信息，机器码就是信息而这些信息储存在内存中。<br><strong>CPU最基本工作方式</strong>：</p><ol><li>取指令：从内存中读取下一条要执行的指令。</li><li>解码指令：搞清楚这条指令是什么意思，是运算？还是内存加载数据。</li><li>执行指令：实际完成指令所要求的操作，比如让加法器开始计算。</li></ol><p>机器码就是由01这两种组成的，形成各种信息。<br>cpu是怎么识别机器码的呢？<br>我自己的理解就是CPU本身就是由上百亿个<strong>晶体管</strong>构成的，<strong>晶体管</strong>可以看成一个用电控制<br>的微型开关，给它一个高电压(代表[1]),开关就打开了，低电压就是[0],电流中断<br>当它读取指令(机器码)的时候，根据高低电压(0,1) 就会形成不同的组合信息</p><p>上面说了，指令储存在内存中，每次CPU都要从内存中拿指令，实在是太麻烦了，所以CPU也有内置的内存<br>叫做<strong>寄存器</strong>，用于储存当前正在被处理的指令，数据或内存地址，访问速度肯定比外面的快<br>不同的CPU也有差别：<br>x86CPU的寄存器(GPR)一般有8个GPR,X64往往有16个GPR，ARM也是有16个。<br>不同的寄存器肯定功能也不一样，后面讲。</p><p>根据机器码，又有了方便人类看懂的汇编语言，毕竟谁会面对只有01的代码一辈子呢？<br>汇编语言可以说是机器码的表现形式，更容易人们对cpu下指令<br>CPU执行的机器码，那我们用高级语言的时候，它是怎么处理的呢？</p><blockquote><p>这里是编译器&#x2F;Compiler 的功能，可以将高级语言转换为CPU受理的底层汇编语言</p></blockquote><h3 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h3><p>你可以吧<strong>指令集架构</strong>想象成CPU的<strong>母语</strong>或<strong>方言</strong><br><strong>CPU</strong>是一个只会说方言的工人<br>指令集就是这种方言的语法规范，它规定了CPU能听懂哪些命令，<br>我们写的所有程序(c++,py,java等)，最终都必须被翻译为CPU能听懂的<strong>方言</strong></p><p>就像中文，英文，日文一样，指令架构也有不同如x86,x64,ARM,MIPS等<br>这里就不细讲，因为我也不知道，还待学~。</p><h2 id="2-最简函数"><a href="#2-最简函数" class="headerlink" title="2. 最简函数"></a>2. 最简函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;&#125;<br><span class="hljs-comment">//非常简单的自定义函数</span><br></code></pre></td></tr></table></figure><h3 id="用x86表现"><a href="#用x86表现" class="headerlink" title="用x86表现"></a>用x86表现</h3><p>GCC是用于反编译x86汇编指令的编译器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">f:<br>moveax,  123<br>ret<br><br></code></pre></td></tr></table></figure><p>MSVC编译器的和上面一样。<br>分析一下：这个函数仅由两条指令构成：第一条将<strong>123</strong>存放到EAX寄存器里；根据函数调用约定<br>后面一条指令会把EAX的值当作返回值传递给调用者函数，而调用者函数(caller)会从EAX寄存器<br>里取值，把它当作返回结果。</p><h3 id="用ARM表现"><a href="#用ARM表现" class="headerlink" title="用ARM表现"></a>用ARM表现</h3><p>Keil编译器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">f <span class="hljs-meta">PROC</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">r0</span>,<span class="hljs-number">#0x7b</span> <span class="hljs-comment">; 123</span><br><span class="hljs-keyword">BX</span>      <span class="hljs-built_in">lr</span><br><span class="hljs-meta">ENDP</span><br></code></pre></td></tr></table></figure><p>ARM程序使用R0寄存器传递函数返回值，所以指令把数值123赋值给R0<br>ARM程序使用LR寄存器储存函数结束之后的返回地址。x86程序使用<strong>栈</strong><br>结构储存上述返回地址。 BX LR 指令的作用是跳转到返回地址，即返回到调用<br>者函数，然后继续执行后续命令</p><h3 id="用MIPS表现"><a href="#用MIPS表现" class="headerlink" title="用MIPS表现"></a>用MIPS表现</h3><p>博主等以后在学，现在用不到，用到什么学什么</p><h2 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3. Hello,world!"></a>3. Hello,world!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//非常著名的程序</span><br></code></pre></td></tr></table></figure><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><h4 id="用MSVC生成汇编"><a href="#用MSVC生成汇编" class="headerlink" title="- 用MSVC生成汇编"></a>- 用MSVC生成汇编</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>CONSTSEGMENT<br>$SG3830 DB &#x27;Hello,world!&#x27;, OAH, ООH<br>CONST ENDS<br><br>PUBLIC _main<br>EXTRN _printf: PROC<br>; Function compile flags: /0dtp<br><br>_TEXT SEGMENT<br>_main PROC<br>push ebp<br>mov  ebp, esp<br>push OFFSET $SG3830<br>call _printf<br>add  esp, 4<br>xor  eax, eax<br>pop  ebp<br>ret  0<br>_main ENDP<br>_TEXT ENDS<br><br></code></pre></td></tr></table></figure><p>这段代码主要分为两个代码段，即CONST和_TEXT段，它们分别代表数据段和代码段</p><ul><li><p>在CONST段：<br>将字符串 Hello,world! 赋值给  $SG3830</p></li><li><p>在_TEXT段：<br>只有一个函数 即主函数main()。在汇编中，主函数的函数体有标志性的<strong>函数序言</strong>和<strong>函数尾声</strong><br>通过push指令将变量$SG3830压入栈。这样_printf就可以调用栈中的指针即’Hello,world!’<br>的地址，调用完成后，$SG3830仍然在栈中，这时候就需要调整栈指针(ESP里的值)，来释放<br>这个指针，所以下一条语句 add esp,4 就是栈指针里的值加4(因为x86是32位4字节)，<br>相当于POP出栈，但是不同是本例是舍弃栈里的数据而POP还要把寄存器里的值存储到既定寄存器<br>然后便是 xor 异或 xor eax , eax 值为0</p></li></ul><h4 id="用GCC编译"><a href="#用GCC编译" class="headerlink" title="- 用GCC编译"></a>- 用GCC编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">Main    proc near<br>var 10  =  dword ptr-10h<br>push ebp<br>mov  ebp, esp<br>and  esp, OFFFFFFF0h<br>sub  esp, 10h<br>mov  eax, offset aHelloWorld; &quot;Hello,world!\n&quot;<br>mov  [esp+10h+var_10], eax<br>call  printf<br>mov  eax, 0<br>leave<br>retn<br>main    endp<br><br></code></pre></td></tr></table></figure><p>GCC生成的汇编指令，与MSVC生成的基本相同,开头 AND ESP, OFFFFFFF0h 指令。它令栈地址(ESP的值) 向16字节边界对齐，属于初始话的指令。如果地址没对齐，CPU可能需要访问两次内存<br>才能获取栈内数据。虽然在8字节边界处对齐就可以满足32位x86 CPU 和 64位 x64 CPU的要求,但是<br>主流编译器的编译规则规定“程序访问的地址必须向16字节对齐(被16整除)”。人们还是为了提高指令<br>的执行效率而特意拟定了这条编译规范。</p><p>SUB ESP,10h 在栈中分配16个字节(这里10h &#x3D; hex(10))，而后便是将字符串地址(指针的值)<br>写入到栈中，此处 GCC用的是 MOV 而MSVC用的是 PUSH 指令。</p><p>mov  [esp+10h+var_10], eax 中的var_10是局部变量，用来向后面printf()函数传递参数<br>mov eax, 0 将eax归零，这里和MSVC又不同， mov指令的opcode是4，而xor的opcode是2</p><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="- x86-64"></a>- x86-64</h3><h4 id="64位下的MSVC编译器"><a href="#64位下的MSVC编译器" class="headerlink" title="- 64位下的MSVC编译器"></a>- 64位下的MSVC编译器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>$SG2989 DB   &#x27;hello, world&#x27;, ООH<br>main PROC<br>sub rsp, 40<br>lea rcx, OFFSET FLAT:$SG2989<br>call printf<br>xor eax, eax<br>add rsp, 40<br>ret 0<br>main ENDP<br><br></code></pre></td></tr></table></figure><p>x86-64 框架的CPU 里,所有的物理寄存器都被扩展为64位寄存器。程序可通过R-字头的名称直接调用整<br>个64位寄存器。为了尽可能充分地利用寄存器、减少访问内存数据的次数,编译器会充分利用寄存器传递函数参<br>数。。也就是说,编译器会优先使用寄存器传递部分参数,再利用内存(数据线)传递其余的参数。<br>Win64的程序还会使用 RCX、RDX、R8、R9这4个寄存器来存放函数参数<br>如： printf()使用 RCX 寄存器传递参数,而没有像32位程序那样使用栈传递数据。</p><p>main()函数的返回值是整数类型的零,但是出于兼容性和可移植性的考虑,C语言的编译器仍将使用 32<br>位的零。换而言之,即使是64位的应用程序,在程序结束时 EAX 的值是零,而RAX 的值不一定会是零。<br>此时,数据栈的对应空间里仍留有40字节的数据。这部分数据空间有个专用的名词,即阴影空间</p><h4 id="GCC"><a href="#GCC" class="headerlink" title="- GCC"></a>- GCC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>.string &quot;hello, world\n&quot;<br>main:<br>sub rsp, 8<br>mov edi, OFFSET FLAT:.LCO; &quot;hello, world&quot;<br>xor eax, eax ; number of vector registers passed<br>call printf<br>xor eax, eax<br>add rsp, 8<br>ret<br><br></code></pre></td></tr></table></figure><p>Linux、BSD 和 Mac OS X 系统中的应用程序,会优先使用RDI、RSI、RDX、RCX、R8、R9这6个<br>寄存器传递函数所需的头6个参数,然后使用数据栈传递其余的参数。<br>因此,64位的GCC 编译器使用 EDI 寄存器(寄存器的32位)存储字符串指针。EDI不过是RDI 寄<br>存器中地址位较低的32位地址部分。为何GCC 不直接使用整个RDI 寄存器?<br>需要注意的是,64位汇编指令 MOV 在写入R-寄存器的低32位地址位的时候,即对E-寄存器进行写<br>操作的时候,会同时清除R寄存器中的高32位地址位。所以,“MOV EAX, 011223344h”能够对 RAX<br>寄存器进行正确的赋值操作,因为该指令会清除(置零)高地址位的内容。</p><h3 id="GCC的其他特性"><a href="#GCC的其他特性" class="headerlink" title="GCC的其他特性"></a>GCC的其他特性</h3><p>只要c语言代码里使用了字符串常量，编译器就会把这个字符串常量置于常量字段，<br>以保证其内容不会发生变化。不过GCC可能会把字符串拆出来单独使用，当还有其他<br>字符串，且里面内容部分相同时</p><h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>等以后再学，目前主要是学习x86,x64</p><h2 id="4-函数序言和函数尾声"><a href="#4-函数序言和函数尾声" class="headerlink" title="4. 函数序言和函数尾声"></a>4. 函数序言和函数尾声</h2><p>函数序言是函数在启动的时候运行的一系列指令。其汇编指令大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>push  ebp<br>mov   ebp, esp<br>sub   esp, X<br><br></code></pre></td></tr></table></figure><p>这些指令的功能是：在栈里保存EBP寄存器的内容,将ESP的值复制到EBP寄存器,然后修改栈的高度<br>以便为本函数的局部变量申请空间</p><p>想象一下，函数开始执行时，它需要一张干净的桌子（栈空间）来摆放自己的东西（局部变量）。<br>但问题是，这张桌子是共用的，上一个函数刚用完，上面可能很乱。<br>函数序言就是为当前函数布置一个稳定、独立工作区的过程。</p><p>在函数执行期间,EBP寄存器不受函数运行的影响，它是函数访问局部变量和函数参数的基准值。<br>虽然我们也可便中 ESP 寄存器存储局部变量和运行参数,但是ESP 寄存器的值总是会发生变化,使用起来并不方便。</p><p>函数在退出时,要做启动过程的反操作,释放栈中申请的内存,还原EBP 寄存器的值,将代码控制权<br>还原给调用者函数(callee)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>mov   esp, ebp<br>pop   ebp<br>ret   0<br><br></code></pre></td></tr></table></figure><p><code>mov   esp, ebp</code>相当于我们一下子，将桌子高变为0，ebp是桌底，赋值给esp是桌高<br>这时栈里的就是进函数时存的ebp，将这弹出赋值给ebp<br>借助函数序言和函数尾声的有关特征,我们可以在汇编语言里识别各个函数。</p><h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5. 栈"></a>5. 栈</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="- 简单介绍"></a>- 简单介绍</h3><p>从技术上说,栈就是CPU 寄存器里的某个指针所指向的一片内存区域。这里所说的“某个指针”通常<br>位于x86&#x2F;x64平台的ESP 寄存器&#x2F;RSP寄存器,以及ARM 平台的SP寄存器。</p><p>操作栈的最常见的指令是PUSH 和POP,在x86 和ARM Thumb 模式的指令集里都有这两条指令。PUSH<br>指令会对 ESP&#x2F;RSP&#x2F;SP 寄存器的值进行减法运算,使之减去4(32位)或8(64位),然后将操作数写到上<br>述寄存器里的指针所指向的内存中。</p><p>POP 指令是PUSH 指令的逆操作:它先从栈指针(Stack Pointer,上面三个寄存器之一)指向的内存中<br>读取数据,用以备用(通常是写到其他寄存器里),然后再将栈指针的数值加上4或8。</p><p>在分配栈的空间之后,栈指针,即 Stack Pointer 所指向的地址是栈的底部。<br>栈底在高地址，栈顶在低地址，PUSH 使 SP 减小（向低地址移动），POP使SP增大（向高地址移动）<br>不理解没关系，看下面。</p><p>多数人想象中的“增长”,是栈从低地址位向高地址位增长,似乎这样才符合自然规律。然而研究过栈<br>的人知道,多数的栈是逆增长的,它会从高地址向低地址增长。也就是说，在PUSH栈，栈指针会减小<br>因为最开始,计算机还是房子的时候,内存由两部分**堆(heap)<strong>和</strong>栈(stack)**构成,比如你<br>只有一个笔记本,但是要记录两门课,怎么办？一门从头开始记,另一门则是从后往前进,所以栈就是<br>这么从以前的习惯保存下来的。</p><h3 id="栈的用途"><a href="#栈的用途" class="headerlink" title="-栈的用途"></a>-栈的用途</h3><h4 id="X86-1"><a href="#X86-1" class="headerlink" title="- X86"></a>- X86</h4><p>当程序使用call调用函数时,call指令结束后的返回地址将被保存在栈里(就是call的下一条指令地址)<br>函数结束后,程序将无条件跳转指令,跳到call的下一条指令。</p><p>CALL指令等价于 “PUSH 返回地址” 和 “JMP 函数地址” 的指令对(组合的意思)。</p><p>被调用函数里的RET 指令,会从栈中读取返回地址然后跳转到这个地址,相当于：<br>“POP 返回地址” + “JMP 返回地址” 指令。</p><p>栈是会溢出的,无限递归就行了，但是这里MSVC编译器会报错,但是GCC不会报错</p><h4 id="ARM-1"><a href="#ARM-1" class="headerlink" title="- ARM"></a>- ARM</h4><p>x86 的一些函数 </p><ul><li>malloc(size)函数： 从堆中申请内存,并返回指向该空间的起始地址指针,但是它只负责分配<br>不负责初始化内容,内存中的值不确定(可能是垃圾值),可使用calloc()来初始化。</li><li>alloca(size)函数： 直接使用栈来分配内存，除此之外和malloc()函数没有显著区别。</li><li>calloc(num,size)函数： 与malloc类似,但是会自动将分配的内存初始化为0。</li><li>printf()函数： 将输出结果输出到stdout(终端)。</li><li>snprint()函数： 将结果输出到buf数组(人工设定的缓冲区),通过puts()将buf输出到stdout.</li></ul><h2 id="说一下"><a href="#说一下" class="headerlink" title="说一下"></a>说一下</h2><p><strong>这本书,有些东西是错的,我也不知道到是翻译的错,还是作者的错；其次有些东西我已经学过几遍了</strong><br><strong>所以就没记录笔记,所以有时候会感觉不全，东一块西一块</strong></p><h2 id="6-条件转移指令"><a href="#6-条件转移指令" class="headerlink" title="6. 条件转移指令"></a>6. 条件转移指令</h2><p>这里会围绕这个c语言来理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f_signed</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br><span class="hljs-keyword">if</span> (a&gt;b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a&gt;b\n&quot;</span>);<br><span class="hljs-keyword">if</span> (a==b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a==b\n&quot;</span>);<br><span class="hljs-keyword">if</span> (a&lt;b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a&lt;b\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f_unsigned</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b)</span>&#123;<br><span class="hljs-keyword">if</span> (a&gt;b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a&gt;b\n&quot;</span>);<br><span class="hljs-keyword">if</span> (a==b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a==b\n&quot;</span>);<br><span class="hljs-keyword">if</span> (a&lt;b)<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;a&lt;b\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br><br>f_signed(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>f_unsigned(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="用MSVC来编译f-signed"><a href="#用MSVC来编译f-signed" class="headerlink" title="用MSVC来编译f_signed"></a>用MSVC来编译f_signed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs asm">a$ = 8<br>b$= 12<br>_f_signed PROC<br>push ebp<br>mov ebp, esp<br>mov eax, DWORD PTR _a$[ebp]<br>cmp eax, DWORD PTR _b$ [ebp]<br>jle SHORT $LN3@f_signed<br>push OFFSET $SG737;&#x27;a&gt;b&#x27;<br>call printf<br>add esp, 4<br><br>$LN3@f_signed:<br>mov ecx, DWORD PTR _a$ [ebp]<br>cmp ecx, DWORD PTR _b$ [ebp]<br>jne SHORT $LN2@f_signed<br>push OFFSET $SG739          ;&#x27;a==b&#x27;<br>call printf<br>add esp, 4<br><br>$LN2@f_signed:<br>mov edx, DWORD PTR _a$ [ebp]<br>cmp edx, DWORD PTR _b$ [ebp]<br>jge SHORT $LN4@f_signed<br>push OFFSET $SG741 ;&#x27;a&lt;b&#x27;<br>call _printf<br>add esp, 4<br><br>$LN4@f_signed:<br>pop ebp<br>ret<br>_f_signed ENDP<br><br></code></pre></td></tr></table></figure><p>第一个条件转移指令是JLE,即“Jump if Less or Equal”。如果上一条 CMP 指令的第一个操作表达式<br>小于或等于(不大于)第二个表达式,JLE 将跳转到指令所标明的地址;如果不满足上述条件,则运行下一条指令。</p><p>本列 <strong>1&lt;2</strong> 会执行JLE跳转到 $LN3@f_signed , JNE “ump if Not Equa”,如果<br>上一条CMP的两个操作符不相等则跳转,<strong>1&lt;2</strong>继续跳 $LN2@f_signed ,这次JGE意思是<br>“Jump if Greater or Equa”。如果CMP 的第一个表达式大于或等于第二个表达式,则进行跳转</p><p><strong>f_unsigned</strong> 函数的汇编和 <strong>f_signed</strong> 差不多,f_nsinged()函数的使用的条件转移指令<br>是JBE 和JAE,而f_signed()函数使用的条件转移指令则是JLE 和JGE</p><h3 id="GCC编译f-unsigned"><a href="#GCC编译f-unsigned" class="headerlink" title="GCC编译f_unsigned"></a>GCC编译f_unsigned</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>_a$ = 8 ; size = 4<br>b$ = 12 ; size = 4<br><br>_f_unsigned PROC<br>push ebp<br>push ebp<br>mov ebp, esp<br>mov eax, DWORD PTR _a$[ebp]<br>cmp eax, DWORD PTR _b$[ebp]<br>jbe SHORT $LN3@f_unsigned<br>push OFFSET $SG2761 ; &#x27;a&gt;b&#x27;<br>call printf<br>add esp, 4<br><br>$LN3@f_unsigned:<br>mov ecx, DWORD PTR _a$[ebp]<br>cmp ecx, DWORD PTR _b$ [ebp]<br>jne SHORT $LN2@f_unsigned<br>push OFFSET $SG2763 ; &#x27;a==b&#x27;<br>call _printf<br>add esp, 4<br><br>$LN2@f_unsigned:<br>mov edx, DWORD PTR _a$ [ebp]<br>cmp edx, DWORD PTR _b$ [ebp]<br>jae SHORT $LN4@f_unsigned<br>push OFFSET $SG2765 ;&#x27;a&lt;b<br>call _printf<br>add esp, 4<br><br>LN4@f_unsigned:<br>Pop ebp<br>Ret 0<br>_f_unsigned ENDP<br><br><br></code></pre></td></tr></table></figure><p>GCC 编译的结果与MSVC 编译的结果基本相同。</p><p>经 GCC 编译后,f_unsigned函数使用的条件转移指令是JBE (Jump if Below or Equal,相当于JLE)<br>和JAE(Jump if Above or Equal,相当于JGE)。JA&#x2F;JAE&#x2F;JB&#x2F;JBE 与 JG&#x2F;JGE&#x2F;JL&#x2F;JLE 的区别,在于它们检查的<br>标志位不同:前者检查借&#x2F;进位标志位CF(1意味着小于)和零标志位 ZF(1意味着相等),后者检查“SF<br>XOR OF” (1意味着异号)和ZF。从指令参数的角度看,前者适用于 unsigned (无符号)类型数据的(CMP)<br>运算,而后者的适用于signed (有符号)类型数据的运算。</p><p>main函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>_main PROC<br>push ebp<br>mov ebp, esp<br>push 2<br>push 1<br>call _f_signed<br>add esp, 8<br>push 2<br>push 1<br>call _f_unsigned<br>add esp, 8<br>xor eax, eax<br>pop ebp<br>ret 0<br>_main ENDP<br><br><br></code></pre></td></tr></table></figure><h3 id="无符号和有符号的不同"><a href="#无符号和有符号的不同" class="headerlink" title="无符号和有符号的不同"></a>无符号和有符号的不同</h3><h4 id="无符号数比较（JA-JB-系列）"><a href="#无符号数比较（JA-JB-系列）" class="headerlink" title="- 无符号数比较（JA&#x2F;JB 系列）"></a>- 无符号数比较（JA&#x2F;JB 系列）</h4><ul><li>无符号数没有正负之分，比较时仅通过进位 &#x2F; 借位判断大小： <ul><li>若 a &lt; b，CMP a, b 会产生借位（CF &#x3D; 1），对应 JB 跳转。</li><li>若 a &gt; b，无借位（CF &#x3D; 0）且不相等（ZF &#x3D; 0），对应 JA 跳转。</li></ul></li></ul><h4 id="有符号数比较（JG-JL-系列）"><a href="#有符号数比较（JG-JL-系列）" class="headerlink" title="- 有符号数比较（JG&#x2F;JL 系列）"></a>- 有符号数比较（JG&#x2F;JL 系列）</h4><ul><li><p>有符号数需考虑正负和溢出，通过符号标志与溢出标志的组合判断：</p><ul><li>若 a &lt; b，当无溢出时 SF &#x3D; 1（结果为负），当溢出时 SF &#x3D; 0（结果符号反转），统一用 SF !&#x3D; OF 判断（JL 跳转）。</li><li>若 a &gt; b，则需 SF &#x3D;&#x3D; OF 且 ZF &#x3D; 0（JG 跳转）。</li></ul></li></ul><p>所以有时候我们可以修改<strong>标志寄存器</strong>就是前面的(CF,SF,ZF等),来执行想要的<strong>语句</strong></p><p>其次条件判断语句可以用 if-else 来替换</p><h2 id="switch-case-default"><a href="#switch-case-default" class="headerlink" title="switch()&#x2F;case&#x2F;default"></a>switch()&#x2F;case&#x2F;default</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br><br><span class="hljs-keyword">switch</span> (a)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;zero\n&quot;</span>); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;one\n&quot;</span>); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;two\n&quot;</span>); <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;something unknown\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br><br>f(<span class="hljs-number">2</span>);<span class="hljs-comment">//test</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="X86-MSVC"><a href="#X86-MSVC" class="headerlink" title="X86 -MSVC"></a>X86 -MSVC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>tv64 = -4 ; size = 4<br>a$ = 8 ; size = 4<br><br>f PROC<br>push ebp<br>mov ebp, esp<br>push ecx<br>mov eax, DWORD PTR _a$ [ebp]<br>mov DWORD PTR tv64 [ebp], eax<br>cmp DWORD PTR tv64[ebp], 0<br>je SHORT $LN4@f<br>cmp DWORD PTR tv64 [ebp], 1<br>je SHORT $LN3@f<br>cmp DWORD PTR tv64 [ebp], 2<br>je SHORT $LN2@f<br>jmpSHORT $LN1@f<br><br>$LN4@f:<br>push OFFSET $SG739 ;&#x27;zero&#x27;, OaH, 00H<br>call _printf<br>add esp, 4<br>jmp SHORT $LN7@f<br><br>$LN3@f:<br>pushOFFSET $SG741 ; &#x27;one&#x27;, Oан, 00H<br>call _printf<br>add esp, 4<br>jmp SHORT $LN7@f<br><br>$LN2@f:<br>push OFFSET $SG743; &#x27;two&#x27;, 0ан, 00H<br>call _printf<br>add esp, 4<br>jmp SHORT $LN7@f<br><br>$LN1@f:<br>pushOFFSET $SG745 ; &#x27;something unknown&#x27;, OaH, OOH<br>call_printf<br>add esp, 4<br><br>$LN7@f:<br>mov esp, ebp<br>dod ebp<br>ret 0<br>_f   ENDP<br><br></code></pre></td></tr></table></figure><p>学到第十三章</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ida使用文档</title>
    <link href="/2025/10/04/01_ida/"/>
    <url>/2025/10/04/01_ida/</url>
    
    <content type="html"><![CDATA[<h1 id="IDA-使用文档"><a href="#IDA-使用文档" class="headerlink" title="IDA 使用文档"></a>IDA 使用文档</h1><h2 id="一、窗口介绍"><a href="#一、窗口介绍" class="headerlink" title="一、窗口介绍"></a>一、窗口介绍</h2><h3 id="1-函数窗口"><a href="#1-函数窗口" class="headerlink" title="1. 函数窗口"></a>1. 函数窗口</h3><ul><li><strong>功能</strong>：显示所有函数列表。</li><li><strong>快捷键</strong>：<code>Ctrl + F</code> 查找函数名（所有表格窗口均支持）。</li></ul><h3 id="2-IDA-View-窗口"><a href="#2-IDA-View-窗口" class="headerlink" title="2. IDA-View 窗口"></a>2. IDA-View 窗口</h3><ul><li><strong>功能</strong>：显示汇编代码。</li><li><strong>快捷键</strong>：<code>空格键</code> 切换图形模式与文本模式。</li></ul><h3 id="3-Pseudocode（伪代码）窗口"><a href="#3-Pseudocode（伪代码）窗口" class="headerlink" title="3. Pseudocode（伪代码）窗口"></a>3. Pseudocode（伪代码）窗口</h3><ul><li><strong>功能</strong>：显示 C&#x2F;C++ 伪代码。</li><li><strong>快捷键</strong>：<code>Tab</code> 切换到对应汇编窗口。</li><li><strong>重命名</strong>：选中关键词后按 <code>N</code>，或右键选择“Rename global item”。</li></ul><h3 id="4-字符串窗口"><a href="#4-字符串窗口" class="headerlink" title="4. 字符串窗口"></a>4. 字符串窗口</h3><ul><li><strong>功能</strong>：列举程序引用的字符串常量。</li><li><strong>快捷键</strong>：<code>Shift + F12</code> 打开字符串窗口；<code>Ctrl + F</code> 搜索字符串。</li></ul><h3 id="5-其他窗口"><a href="#5-其他窗口" class="headerlink" title="5. 其他窗口"></a>5. 其他窗口</h3><ul><li><strong>HEX View</strong>：内存十六进制视图</li><li><strong>Exports</strong>：导出函数</li><li><strong>Imports</strong>：导入函数</li><li><strong>Structures</strong>：结构体定义</li></ul><blockquote><p><strong>提示</strong>：大部分窗口入口可在菜单栏 <code>View</code> 中找到。</p></blockquote><hr><h2 id="二、常用快捷键"><a href="#二、常用快捷键" class="headerlink" title="二、常用快捷键"></a>二、常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Ctrl + X</code></td><td>查看交叉引用（字符串&#x2F;变量被引用的函数）</td></tr><tr><td><code>Ctrl + Z</code></td><td>撤销操作</td></tr><tr><td><code>Alt + T</code></td><td>查找汇编指令，<code>F3</code> 查找下一个</td></tr><tr><td><code>Alt + M</code></td><td>添加标签描述</td></tr><tr><td><code>Ctrl + M</code></td><td>搜索标签并跳转</td></tr><tr><td><code>\</code></td><td>隐藏&#x2F;显示类型转换（如 <code>*(_DWORD *)</code>）</td></tr><tr><td><code>F5</code>&#x2F;<code>Tab</code></td><td>反编译为 C 伪代码窗口</td></tr><tr><td><code>H</code></td><td>十六进制与十进制切换（Hex-View）</td></tr><tr><td><code>D</code></td><td>转换字节显示方式</td></tr><tr><td><code>U</code></td><td>拆分字节数据</td></tr><tr><td><code>C</code></td><td>重新分析为汇编代码</td></tr><tr><td><code>/</code></td><td>汇编界面显示伪代码（需支持 F5）</td></tr><tr><td><code>R</code></td><td>转换为字符串类型显示</td></tr><tr><td><code>N</code></td><td>修改变量&#x2F;函数名称</td></tr><tr><td><code>Y</code></td><td>修改变量类型</td></tr><tr><td><code>M</code></td><td>查看 API 参数名称</td></tr><tr><td><code>P</code></td><td>重新生成函数</td></tr><tr><td><code>Ctrl +Alt + K</code></td><td>修改汇编指令</td></tr></tbody></table><hr><h2 id="三、IDA-调试器功能"><a href="#三、IDA-调试器功能" class="headerlink" title="三、IDA 调试器功能"></a>三、IDA 调试器功能</h2><ol><li><strong>断点类型</strong>：软件断点、硬件断点、条件断点、脚本断点</li><li><strong>调试控制</strong>：步入、步过、步出、运行到光标</li><li><strong>调试级别</strong>：汇编级、伪代码级、源码级</li><li><strong>寄存器&#x2F;内存</strong>：读写寄存器与内存</li><li><strong>调试方式</strong>：启动进程调试、附加调试</li></ol><h3 id="调试相关菜单功能"><a href="#调试相关菜单功能" class="headerlink" title="调试相关菜单功能"></a>调试相关菜单功能</h3><ul><li><strong>Quick debug view</strong>：快速查看寄存器、内存等关键信息</li><li><strong>Debugger windows</strong>：打开调试辅助窗口（如反汇编、寄存器、内存等）</li><li><strong>Breakpoints</strong>：设置、编辑、删除、管理断点</li><li><strong>Watches</strong>：监视变量或表达式的值</li><li><strong>Tracing</strong>：记录程序执行轨迹，便于分析流程</li><li><strong>Start process</strong>：<code>F9</code> 启动新进程并调试</li><li><strong>Attach to process</strong>：附加到已运行进程或远程进程</li><li><strong>Process options…</strong>：配置调试进程参数（环境变量、工作目录等）</li><li><strong>Pause process</strong>：暂停进程，检查当前状态</li><li><strong>Terminate process</strong>：终止进程</li><li><strong>Detach from process</strong>：分离调试器，进程继续运行</li><li><strong>Refresh memory</strong>：刷新内存视图</li><li><strong>Take memory snapshot</strong>：内存快照，便于对比分析</li><li><strong>Step into</strong>：<code>F7</code> 单步进入函数</li><li><strong>Step over</strong>：<code>F8</code> 单步跳过函数</li><li><strong>Run until return</strong>：<code>Ctrl + F7</code> 运行至当前函数返回</li><li><strong>Run to cursor</strong>：<code>F4</code> 运行到光标处</li><li><strong>Switch to source</strong>：切换到源代码视图</li><li><strong>Use source-level debugging</strong>：启用源码级调试</li><li><strong>Open source file…</strong>：打开源代码文件</li><li><strong>Debugger options…</strong>：调试器全局配置</li><li><strong>Switch debugger…</strong>：切换不同类型调试器</li></ul><hr><h2 id="四、内存修改技巧"><a href="#四、内存修改技巧" class="headerlink" title="四、内存修改技巧"></a>四、内存修改技巧</h2><ul><li>在 <strong>Hex View</strong> 表中可直接修改内存数值。</li><li>找到要修改的位置，按 <code>F2</code> 进行编辑，再按一次 <code>F2</code> 确认修改。</li><li>右键选择 <code>Edit</code> 也可修改。</li><li>推荐插件：<strong>lazyIDA</strong>，可批量粘贴修改内容。</li></ul><hr><h2 id="五、调试技巧：通过修改-EIP-RIP-强制执行函数"><a href="#五、调试技巧：通过修改-EIP-RIP-强制执行函数" class="headerlink" title="五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数"></a>五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数</h2><ul><li><strong>EIP</strong>（32位）或 <strong>RIP</strong>（64位）寄存器存储 CPU 下一条指令地址。</li><li>修改 EIP&#x2F;RIP 可让 CPU 跳转执行任意函数。</li></ul><p><strong>操作步骤：</strong></p><ol><li>找到目标函数地址（十六进制）。</li><li>在合适位置设置断点，开始调试。</li><li>在寄存器窗口双击 EIP&#x2F;RIP，修改为目标地址（或右键 Edit）。</li><li>取消断点，继续运行即可。</li></ol><hr><h2 id="六、博主见到的一些情况："><a href="#六、博主见到的一些情况：" class="headerlink" title="六、博主见到的一些情况："></a>六、博主见到的一些情况：</h2><ul><li>**堆栈问题：**当你在汇编中看到一大串的数据的时候,可能是堆栈问题,可能会有提示,<br>只需选中数据按c,重新分析为汇编就行了</li></ul><hr><ul><li>**动态调式：**在做题的时候,可能会有静态里找不到需要的信息,或程序运行时发生改变,<br>比如简单的base64,它可能会在程序运行时原来的映射表给换了,所以你怎么也解不出,所以需要你动态<br>的调试一下,还有一些题会靠你远程调试之类的</li></ul><hr><ul><li>**栈帧不平衡：**在使用IDA进行反编译时，可能会遇到栈帧不平衡的问题。这通常会导致反编译结果出错，<br>例如无法正确生成伪代码。<br>在伪代码中可能有:<blockquote><p><code> positive sp value has been detected, the output may be wrong!</code><br>在反编译时会报错:<br><code>positive sp value has been found</code><br>以下是解决栈帧平衡问题的常见方法。</p></blockquote></li></ul><ol><li>打开 <code>Options</code> -&gt; <code>General</code> -&gt; <code>Stack pointer</code>。这样可以看到指针了</li><li>找到红色标记区域(表示栈帧不平衡)</li><li>找到栈指为负的选中按 <code>Alt + K</code> 打开栈帧调整窗口。</li><li>修改栈偏移值(例如:将负值修改为0或更高的值)</li><li>修改后保存重新编译</li></ol><hr><blockquote><p>本文档适用于 IDA Pro 基础及进阶使用，欢迎在博客留言交流更多技巧！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>逆向软件使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Base64加密算法</title>
    <link href="/2025/10/04/03_Base64/"/>
    <url>/2025/10/04/03_Base64/</url>
    
    <content type="html"><![CDATA[<p><strong>MD5和SHA256加密是不可逆的</strong></p><p><strong>base64是可逆的</strong></p><p>在python脚本中</p><p>开始要引入 base64</p><p>import 是引入的意思；</p><p><strong>import base64</strong></p><p>开始默认映射的是顺序是 <strong>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>要解密的为data</p><p><strong>data &#x3D; “SGVsbG8gV29ybGQ&#x3D;”</strong></p><p>则flag为</p><p><strong>flag_byte &#x3D; base64.b64decode(data)</strong></p><p>这里是base64调用 b64decode()函数 ，该函数是将已经加密的字符返回</p><p>b64decode() 函数返回的是字节，需要经过 decode(“utf-8”) 转换为字符串</p><p><strong>flag &#x3D; flag_byte.decode(“utf-8”)</strong></p><p><strong>print(flag)</strong></p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p><strong>有一些的变形：</strong></p><h4 id="映射改变了"><a href="#映射改变了" class="headerlink" title="映射改变了"></a><strong>映射改变了</strong></h4><p><strong>T1 &#x3D; “&#x2F;T+US9VR8WQ7XP6YO5ZN4aM3bL2cK1dJ0eIzfHygGxhFwiEvjDukCtlBsmArnqop”</strong></p><p><strong>target &#x3D; “NHPNOt5VdCixcy5JclLJLVHyLyauLMmC3CWeKl4lPRC&#x2F;“</strong></p><p>原本的是 :</p><p><strong>alphabet &#x3D; “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>创建映射表并转换：</p><p><strong>创建映射表：str.maketrans(x,y)</strong></p><p>x中的第一个字符映射到y中的第一个字符，以此类推</p><p><strong>根据映射表替换字符串中的字符: string.translate(table)</strong></p><p><strong>translation_table &#x3D; str.maketrans(T1,alphabet)</strong></p><p><strong>standard_encoded &#x3D; target.translate(translation_table)</strong></p><p><strong>解码：</strong></p><p><strong>decoded_bytes &#x3D; base64.b64decode(standard_encoded)</strong></p><p><strong>flag &#x3D; decoded_bytes.decode(‘utf-8’)</strong></p><p><strong>print(flag)</strong></p>]]></content>
    
    
    <categories>
      
      <category>加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base64</tag>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upx脱壳</title>
    <link href="/2025/10/04/05_Upx/"/>
    <url>/2025/10/04/05_Upx/</url>
    
    <content type="html"><![CDATA[<p>upx壳是一种压缩的壳，正常进入ida中会隐藏真正的汇编代码</p><p>首先将文件拖入PE中查看是否加壳和位数<br>在最后一行的info信息中如果出现upx，那就代表经过了upx加壳</p><p>有针对脱壳的工具upx-5.0.2-win64 </p><p>找到upx-5.0.2-win64文件中的upx后打开终端，然后输入 upx -d 程序名称<br>这里程序名称要的是绝对地址或相对地址，当然你也可以将程序拖到终端中<br>然后会自动脱壳，如果失败，根据提示具体解决<br>当然也有反upx脱壳工具的程序，也会导致脱壳失败，这是需要手动脱壳</p><p>OEP(Original Entry Point)是程序的原始入口点的位置，EP(Entry Point)是程序的入口点，加壳之后，程序的入口点会被改动，所以有OEP，<br>需要从OEP开始脱壳，有两个指令，一个是pushad，还有popad，从pushad开始找，一直运行到结束</p><p>OEP：(Original Entry Point)，程序的原始入口点，软件加壳就是隐藏了EP， 只要我们找到程序的OEP，就可以立刻脱壳。<br>PUSHAD （压栈） 代表程序的入口点，POPAD （出栈） 代表程序的出口点，与PUSHAD相对应，一般找到这个OEP就在附近啦。</p><p>进入到程序里面后找到文件的入口<br>pushad意味着upx壳解压缩代码的入口。<br>64位程序中没有pushad，而是用几个push汇编代码替代。32位程序中存在pushad。<br>像这样的：<br>push rbx;<br>push rsi;<br>push rdi;<br>push rbp;  几个连一起的</p><p>第一就是用x32|64 找到入口：<br>点击断点 -&gt; 查找入口 -&gt; 找到之后点进去将第一行设为原始断点 EIP<br>-&gt; 之后按F8步过直到 ESP(FPU窗口) 发生变化 -&gt; 点击ESP右键找到”在内存窗口中转到” 点击<br>-&gt; 在地址窗口中将该地址右键 -&gt; 找到断点 -&gt;访问 -&gt; 2字节 -&gt; 之后便是运行会出现真正的函数窗口<br>-&gt; 之后便是用 Scylla x86 来将程序修复</p>]]></content>
    
    
    <categories>
      
      <category>加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UPX脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TEA加密算法</title>
    <link href="/2025/10/04/04_TEA/"/>
    <url>/2025/10/04/04_TEA/</url>
    
    <content type="html"><![CDATA[<p>TEA、XTEA、XXTEA算法采用64位的明文分组和128位的密钥。算法中使用了一个神秘常数δ（delta），它来源于黄金比率，用于保证每一轮加密都不相同。δ的精确值并不关键，通常定义为δ&#x3D;「(√5 - 1)2^31」（即0x9E3779B9），在做题中可能会变，但没有影响。</p><p> <strong>密钥长度</strong></p><p>TEA：使用128位密钥。</p><p>XTEA：通常使用128位或256位密钥。</p><p>XXTEA：密钥长度更灵活，可以使用任意长度的密钥。</p><p>&nbsp;<strong>加密轮数</strong></p><p>TEA：通常进行32轮加密。</p><p>XTEA：默认进行64轮加密。</p><p>XXTEA：加密轮数更多，具体轮数取决于数据块和密钥的长度。</p><p><strong>加密算法</strong></p><p>TEA：加密过程使用简单的加法、异或和移位操作。</p><p>XTEA：在TEA的基础上增加了更多的变量和操作，例如密钥的不规则混合。</p><p>XXTEA：进一步改进了轮加密过程，使用了更多的变量和操作，并且利用相邻字进行加密。</p><h5 id="TEA加密算法（公式）："><a href="#TEA加密算法（公式）：" class="headerlink" title="TEA加密算法（公式）："></a>TEA加密算法（公式）：</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to 31</p><p>&nbsp;              sum +&#x3D; delta</p><p>&nbsp;X0 +&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;X1 +&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * 32;</p><p>&nbsp;for i&#x3D;0 to 31</p><p>&nbsp;X1 -&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;X0 -&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;sum -&#x3D; delta;</p><h5 id="XTEA加密算法（公式）"><a href="#XTEA加密算法（公式）" class="headerlink" title="XTEA加密算法（公式）:"></a>XTEA加密算法（公式）:</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;      X0 +&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;sum +&#x3D; delta</p><p>&nbsp;X1 +&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * Round;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;X1 -&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;sum -&#x3D; delta</p><p>&nbsp;      X0 -&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><h5 id="XXTEA加密（公式）："><a href="#XXTEA加密（公式）：" class="headerlink" title="XXTEA加密（公式）："></a>XXTEA加密（公式）：</h5>]]></content>
    
    
    <categories>
      
      <category>加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密算法</tag>
      
      <tag>TEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RC4加密算法</title>
    <link href="/2025/10/04/02_RC4/"/>
    <url>/2025/10/04/02_RC4/</url>
    
    <content type="html"><![CDATA[<p><strong>RC4 是典型的对称加密算法</strong></p><p>对称加密的核心特征是加密与解密过程依托同一密钥完成。在数据传输场景中：</p><p>发送方：利用密钥对明文执行加密变换，通过特殊算法将明文转化为复杂密文后对外传输；</p><p>接收方：需调用加密时的相同密钥，结合算法的逆运算对密文解密，还原出可读明文，以此保障数据传输的保密性。</p><p><strong>RC4 算法特性与安全性</strong></p><p>RC4 算法具备实现简单、运算高效的优势，其密钥长度支持动态调整，范围覆盖 1 - 256 字节（对应 8 - 2048 比特） 。加密时，会依据密钥及密钥长度生成密钥流，且密钥流长度与明文长度严格匹配，加密和解密流程复用同一算法逻辑，密钥流的生成完全由密钥内容与长度决定。</p><p>在现代技术环境下，当密钥长度达到 128 比特时，暴力枚举密钥的攻击方式已不具备可行性 。由于暴力破解需尝试近乎 “2^128” 数量级的密钥组合，计算量超乎现有算力承载极限，因此可预见在未来较长周期内，RC4 算法凭借其密钥长度设计，能够抵御暴力密钥搜索攻击。截至目前，针对 128 比特密钥长度的 RC4 加密，尚未出现经实践验证的有效攻击手段，一定程度上保障了算法应用的安全性。</p><p><strong>RC4 算法核心组成</strong></p><p>RC4 加密流程主要由两部分构成：</p><p>初始化算法（KSA，Key - Scheduling Algorithm）：负责对初始的密钥状态进行处理，基于输入密钥打乱内部状态数组，为后续生成密钥流做准备；</p><p>加密算法（PRGA，Pseudo - Random Generation Algorithm ，实际常与 KSA 协同表述）：依托 KSA 初始化后的状态，逐字节生成伪随机密钥流，通过密钥流与明文的按位异或（XOR）操作，完成加密（解密为逆过程，复用相同密钥流与异或逻辑 ），最终输出密文（或还原明文 ）。</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>&#x2F;&#x2F; 初始化RC4的S盒</p><p>void rc4_init(unsigned char *s, unsigned char *key, unsigned long key_len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0;</p><p>&nbsp;   unsigned char k[256] &#x3D; {0};</p><p>&nbsp;   unsigned char temp &#x3D; 0;</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 初始化S盒和K盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       s[i] &#x3D; i;</p><p>&nbsp;       k[i] &#x3D; key[i % key_len];  &#x2F;&#x2F; 用密钥循环填充K盒</p><p>&nbsp;   }</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 打乱S盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       j &#x3D; (j + s[i] + k[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;   }</p><p>}</p><p>&#x2F;&#x2F; RC4加解密（数据会被直接修改）</p><p>void rc4_crypt(unsigned char *s, unsigned char *data, unsigned long len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;</p><p>&nbsp;   unsigned long k &#x3D; 0;</p><p>&nbsp;   unsigned char temp;</p><p>&nbsp;   </p><p>&nbsp;   for (k &#x3D; 0; k &lt; len; k++) {</p><p>&nbsp;       i &#x3D; (i + 1) % 256;</p><p>&nbsp;       j &#x3D; (j + s[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;       &#x2F;&#x2F; 生成密钥流并异或</p><p>&nbsp;       t &#x3D; (s[i] + s[j]) % 256;</p><p>&nbsp;       data[k] ^&#x3D; s[t];</p><p>&nbsp;   }</p><p>}</p><p>int main() {</p><p>&nbsp;   unsigned char s[256] &#x3D; {0};</p><p>&nbsp;   char key[] &#x3D; “zhaosh”;               &#x2F;&#x2F; 密钥</p><p>&nbsp;   unsigned char data[] &#x3D; {12, 23, 3, 4, 4, 4, 3, 0x7F, 12, 1, 21, 3, 23};  &#x2F;&#x2F; 修正超出char范围的值</p><p>&nbsp;   unsigned long data_len &#x3D; sizeof(data);  &#x2F;&#x2F; 用sizeof计算二进制数据长度</p><p>&nbsp;   unsigned long key_len &#x3D; strlen(key);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 加密过程</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“加密后数据（十六进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%02X “, data[i]);  &#x2F;&#x2F; 用十六进制显示二进制数据</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 解密过程（需要重新初始化S盒）</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);  &#x2F;&#x2F; 重新初始化</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“解密后数据（十进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%d “, data[i]);</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   return 0;</p><p>}</p>]]></content>
    
    
    <categories>
      
      <category>加密算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密算法</tag>
      
      <tag>RC4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些偏门的运算</title>
    <link href="/2025/10/04/SomeNicheOperations/"/>
    <url>/2025/10/04/SomeNicheOperations/</url>
    
    <content type="html"><![CDATA[<h5 id="模运算的逆运算："><a href="#模运算的逆运算：" class="headerlink" title="模运算的逆运算："></a><strong>模运算的逆运算：</strong></h5><p><strong>加密后 &#x3D; (原始值 + 偏移) % 模值</strong>     </p><p>**原始值 &#x3D; (加密后 - 偏移 + 模值) % 模值    &#x2F;&#x2F;**这里加上模值是因为取模可能是负数</p><p>这个式子成立的关键是     0&lt;&#x3D; 原始值 &lt;&#x3D; 模值，这是字符加密的常见场景；</p><p>当不成立时就是 **原始值 &#x3D; (加密后 - 偏移 + 模值*k) % 模值 ,**你可以自己写一下数字，模拟一下；</p><h5 id="生成随机数："><a href="#生成随机数：" class="headerlink" title="生成随机数："></a><strong>生成随机数：</strong></h5><p><strong>rand(),srand()</strong></p><p>rand_num &#x3D; rand() % num +a  这里的num是生成数的区间，a是区间的左区间</p><p>对于区间[a, b)的随机整数：(rand() % (b-a)) + a</p><p>对于区间[a, b]的随机整数：(rand() % (b-a+1)) + a</p><p>srand()函数用于设置rand()函数生成随机数时所用的种子,</p><p>当用rand而不设种子时，后面的随机数是相同的，可以理解为rand函数是根据时间轴而生成数的，</p><p>rand生成数的时间轴需要srand来更换</p><p><strong>用法：</strong></p><p>用rand 需要引入头文件stdlib</p><p>需要引入<strong>time</strong>头文件，在开头写入<strong>srand((unsigned)time(NULL));</strong> 就行</p><h4 id="使用-Python-的numpy库直接求解线性方程组"><a href="#使用-Python-的numpy库直接求解线性方程组" class="headerlink" title="使用 Python 的numpy库直接求解线性方程组"></a>使用 Python 的numpy库直接求解线性方程组</h4><p>当有解方程组是多元的时候就用</p><h3 id="a-a-4-a"><a href="#a-a-4-a" class="headerlink" title="a &#x3D; (a&gt;&gt;4) | (a&lt;&lt;4) 高位低位互换"></a>a &#x3D; (a&gt;&gt;4) | (a&lt;&lt;4) 高位低位互换</h3><p>这是做题遇到的 <a href="https://www.nssctf.cn/problem/3323">MoeCTF 2022chicken_soup</a><br>是一个花之令题,<br>举个列子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1010</span> <span class="hljs-number">1011</span> = <span class="hljs-number">0xAB</span><br>左移<span class="hljs-number">4</span>位  <span class="hljs-number">1011</span> <span class="hljs-number">0000</span> = <span class="hljs-number">0xB0</span><br>右移<span class="hljs-number">4</span>位<span class="hljs-number">0000</span> <span class="hljs-number">1010</span> = <span class="hljs-number">0x0A</span><br><br>OR操作:  <span class="hljs-number">1011</span> <span class="hljs-number">0000</span> | <span class="hljs-number">0000</span> <span class="hljs-number">1010</span> = <span class="hljs-number">1011</span> <span class="hljs-number">1010</span> = <span class="hljs-number">0xBA</span><br><br>结果就是: <span class="hljs-number">0xAB</span> -&gt; <span class="hljs-number">0xBA</span> 高<span class="hljs-number">4</span>位和低<span class="hljs-number">4</span>位交换<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些运算技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据储存</title>
    <link href="/2025/10/04/dataStorage/"/>
    <url>/2025/10/04/dataStorage/</url>
    
    <content type="html"><![CDATA[<h2 id="数据在内存中的表示"><a href="#数据在内存中的表示" class="headerlink" title="数据在内存中的表示"></a>数据在内存中的表示</h2><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="基础：bit-与-byte"><a href="#基础：bit-与-byte" class="headerlink" title="基础：bit 与 byte"></a>基础：bit 与 byte</h3><p>bit（比特&#x2F;位）是最小的数据单位，只有两种状态：0 或 1。计算机底层的数字电路（由晶体管构成）对应导通&#x2F;截止两个状态，天然适合以二进制表示信息。</p><p>byte（字节）通常为 8 个 bit。1 byte &#x3D; 8 bit，因此每字节可以表示 2^8 &#x3D; 256 个不同值（0 到 255）。这足以编码英文字母、数字、标点等常见字符。</p><p>常见表示方式示例：</p><h3 id="3-整数在内存中的表示"><a href="#3-整数在内存中的表示" class="headerlink" title="3. 整数在内存中的表示"></a>3. 整数在内存中的表示</h3><ul><li>无符号整数（unsigned）：按二进制直接表示，n 位能表示 0 到 2^n - 1。</li><li>有符号整数（signed）：通常使用补码（two’s complement）表示法，n 位补码表示范围为 -2^{n-1} 到 2^{n-1}-1。</li></ul><p>示例（常见位宽）：</p><ul><li>uint8: 0 ~ 255</li><li>int8: -128 ~ 127（补码）</li><li>uint16: 0 ~ 65535</li><li>int16: -32768 ~ 32767</li><li>uint32 &#x2F; int32，uint64 &#x2F; int64 等类似扩展</li></ul><p>注意：相同的字节序列，在解释为有符号或无符号整数时会产生不同的数值。调试或解析二进制数据时必须知道数据类型。</p><h3 id="4-浮点数（IEEE-754）"><a href="#4-浮点数（IEEE-754）" class="headerlink" title="4. 浮点数（IEEE 754）"></a>4. 浮点数（IEEE 754）</h3><p>现代系统普遍使用 IEEE 754 标准来表示浮点数（单精度 float32、双精度 float64）。表示由符号位、指数位和尾数（格数）构成。浮点的存储方式有别于整数，直接查看字节需要按照 IEEE 754 规则解码。</p><p>示例（float32）：1 位 符号，8 位 指数，23 位 尾数。浮点还包含特殊值：正负零、无穷（Inf）、非数（NaN）和非规格化数。</p><h3 id="5-字符串与编码"><a href="#5-字符串与编码" class="headerlink" title="5. 字符串与编码"></a>5. 字符串与编码</h3><ul><li>ASCII：单字节编码，适用于英文与基础控制字符。</li><li>UTF-8：变长编码，兼容 ASCII，常用于互联网与现代应用。</li><li>UTF-16 &#x2F; UTF-32：宽字符编码，常见于某些平台或语言（需注意字节序和 BOM）。</li></ul><p>字符串在内存中通常以字节序列保存：有的语言&#x2F;库以 NUL 字节结尾（C 风格），有的用长度前缀或对象管理长度与容量。</p><h3 id="6-对齐（Alignment）与填充（Padding）"><a href="#6-对齐（Alignment）与填充（Padding）" class="headerlink" title="6. 对齐（Alignment）与填充（Padding）"></a>6. 对齐（Alignment）与填充（Padding）</h3><p>CPU 访问内存通常对对齐有性能要求。比如 32 位整数按 4 字节对齐通常更高效。编译器在结构体内可能插入填充字节以满足对齐规则，这会影响结构体大小和字段偏移，进而影响序列化与跨平台兼容性。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Example</span> &#123;</span><br><span class="hljs-type">char</span> a;    <span class="hljs-comment">// 1 byte</span><br><span class="hljs-comment">// 3 bytes padding</span><br><span class="hljs-type">int</span> b;     <span class="hljs-comment">// 4 bytes</span><br>&#125;;<br><span class="hljs-comment">// sizeof(Example) 可能为 8 而不是 5</span><br></code></pre></td></tr></table></figure><h3 id="7-常见示例与转换"><a href="#7-常见示例与转换" class="headerlink" title="7. 常见示例与转换"></a>7. 常见示例与转换</h3><ul><li>十六进制&#x2F;二进制&#x2F;十进制互转示例：0x6B &#x3D; 二进制 01101011 &#x3D; 十进制 107</li><li>32 位整数（0x12345678）在内存中的排列：<ul><li>大端（Big-endian）: 12 34 56 78</li><li>小端（Little-endian）: 78 56 34 12</li></ul></li></ul><p>Python 示例（查看字节序）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct<br><br>x = <span class="hljs-number">0x12345678</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;big:&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&gt;I&#x27;</span>, x).<span class="hljs-built_in">hex</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;little:&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, x).<span class="hljs-built_in">hex</span>())<br><br>f = <span class="hljs-number">3.14</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;float32 little hex:&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;&lt;f&#x27;</span>, f).<span class="hljs-built_in">hex</span>())<br></code></pre></td></tr></table></figure><h3 id="8-快速参考表"><a href="#8-快速参考表" class="headerlink" title="8. 快速参考表"></a>8. 快速参考表</h3><ul><li>1 byte &#x3D; 8 bits</li><li>uint8: 0 ~ 255</li><li>int8 (补码): -128 ~ 127</li><li>常见对齐：int32 按 4 字节对齐，int64 按 8 字节对齐（视平台而定）</li></ul><h3 id="9-后续改进建议"><a href="#9-后续改进建议" class="headerlink" title="9. 后续改进建议"></a>9. 后续改进建议</h3><ul><li>添加字节顺序与结构体内存布局的可视化图示</li><li>增加 C&#x2F;C++&#x2F;Go&#x2F;Rust 的序列化反序列化示例</li><li>给出常用工具的使用方法：hexdump&#x2F;xxd、GDB&#x2F;WinDbg、Wireshark（网络字节序分析）</li></ul><hr><p>如果需要，我可以把上述示例扩展为具体语言的完整代码片段，并添加 hexdump&#x2F;xxd 的示例输出以便学习与调试。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>另外一些加密算法</title>
    <link href="/2025/10/04/otherAlgorithms/"/>
    <url>/2025/10/04/otherAlgorithms/</url>
    
    <content type="html"><![CDATA[<h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h2><p>凯撒加密是一种简单的替换加密技术，将明文中的所有字母全部偏移key个单位来进行加密。</p><h3 id="加密实现"><a href="#加密实现" class="headerlink" title="加密实现"></a>加密实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义字母表模型</span><br>model1 = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  <span class="hljs-comment"># 小写字母</span><br>model2 = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>  <span class="hljs-comment"># 大写字母</span><br><br><span class="hljs-comment"># 明文和密钥</span><br>plaintext = <span class="hljs-string">&quot;flag&#123;i_LOVE_Reverse&#125;&quot;</span><br>key = <span class="hljs-number">11</span><br><br><span class="hljs-comment"># 加密过程</span><br>encrypted = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> plaintext:<br>    <span class="hljs-keyword">if</span> s.islower():<br>        n = model1.find(s)<br>        s = model1[(n + key) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 取模运算防止索引越界</span><br>    <span class="hljs-keyword">elif</span> s.isupper():<br>        n = model2.find(s)  <span class="hljs-comment"># 修复bug：大写字母应使用model2</span><br>        s = model2[(n + key) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 修复bug：大写字母应使用model2</span><br>    encrypted += s<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;加密结果：&quot;</span>, encrypted)  <span class="hljs-comment"># 输出：qwlr&#123;t_WZGP_Cpgpcdp&#125;</span><br></code></pre></td></tr></table></figure><h3 id="解密实现"><a href="#解密实现" class="headerlink" title="解密实现"></a>解密实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 解密过程（尝试所有可能的密钥）</span><br>ciphertext = <span class="hljs-string">&quot;qwlr&#123;t_WZGP_Cpgpcdp&#125;&quot;</span><br><br><span class="hljs-keyword">for</span> key_try <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">27</span>):<br>    decrypted = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> ciphertext:<br>        <span class="hljs-keyword">if</span> s.islower():<br>            n = model1.find(s)<br>            s = model1[(n - key_try) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 反向偏移</span><br>        <span class="hljs-keyword">elif</span> s.isupper():<br>            n = model2.find(s)<br>            s = model2[(n - key_try) % <span class="hljs-number">26</span>]  <span class="hljs-comment"># 反向偏移</span><br>        decrypted += s<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;密钥 <span class="hljs-subst">&#123;key_try&#125;</span>: <span class="hljs-subst">&#123;decrypted&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 当key_try=11时，将得到原始明文</span><br></code></pre></td></tr></table></figure><h2 id="ROT13加密"><a href="#ROT13加密" class="headerlink" title="ROT13加密"></a>ROT13加密</h2><p>ROT13是凯撒加密的一个特例，固定将字母向后移动13位。由于字母表共有26个字母，对同一文本应用两次ROT13即可恢复原始文本。非英文字母的字符（如数字、符号）则保持不变。</p><h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ROT13加密函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rot13</span>(<span class="hljs-params">flag</span>) &#123;<br>    <span class="hljs-keyword">return</span> flag.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[a-zA-Z]/g</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-comment">// 将字符转换为Unicode编码并加13</span><br>        <span class="hljs-comment">// 如果结果超过字母范围（大写字母90，小写字母122），则减26回到范围内</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>((c &lt;= <span class="hljs-string">&quot;Z&quot;</span> ? <span class="hljs-number">90</span> : <span class="hljs-number">122</span>) &gt;= (c = c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)+ <span class="hljs-number">13</span>) ? c : c - <span class="hljs-number">26</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术解析"><a href="#技术解析" class="headerlink" title="技术解析"></a>技术解析</h3><ul><li><code>String.fromCharCode()</code> 函数：将Unicode编码转换为对应的字符</li><li><code>charCodeAt()</code> 函数：将字符转换为对应的Unicode编码</li><li><code>(c &lt;= &quot;Z&quot; ? 90 : 122)</code>：判断字符是大写还是小写，分别获取字母表边界值</li><li><code>(c = c.charCodeAt(0)+ 13)</code>：将字符转换为Unicode编码并加13</li><li><code>(c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0)+ 13)</code>：判断是否超出字母范围，超出则需要回滚到字母表开始位置</li><li>由于字母共有26个，ROT13的特性使得加13和减13效果相同，加密和解密可以使用同一个函数</li></ul><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>前提了解 欧拉函数<br>欧拉函数是小于n的正整数中与n互质的数目 ， 那n为质数的话则 (n)为 n-1<br>如果一个数n为两个质数p,q的积，则改欧拉函数为(n) &#x3D; (q-1)*(p-1)</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.开始要先选取两个互质的数p 、q,这里数要很大<br>    (1)p,q一般为512b，使n到1024b,重要的运用时p,q为1024b,使n达到2048b<br>    (2)p,q应为强素数,且p,q差要大<br>    (3)(p-1)和(q-1)的最大公因数最小<br>2.找到p,q后便计算(n),n,将n公开<br>3.随机找一个正整数e，1 &lt; e &lt; (n) ,且 e和(n)互质<br>4.根据e和(n)找到一个整数d为模反元素，模反元素就是 ed % (n) &#x3D; 1<br>5.公钥 k &#x3D; &lt;e,n&gt; ; 私钥：k &#x3D; &lt;d,p,q,(n)&gt;<br>6.加密算法：C &#x3D; M(e) mod n  这里括号是次方的意思<br>7.解密运算：M &#x3D; C(d) mod n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里给一个题，是buuctf里的rsa</span><br><span class="hljs-comment">#打开key.enc的文件是</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#-----BEGIN PUBLIC KEY-----</span><br><span class="hljs-comment"># MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+</span><br><span class="hljs-comment"># /AvKr1rzQczdAgMBAAE=</span><br><span class="hljs-comment">#-----END PUBLIC KEY-----</span><br><span class="hljs-comment">#首先判断一下，通常这种 PEM 的格式里面是Base64编码的DER数据</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes, bytes_to_long<br>key_base = <span class="hljs-string">&quot;MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+/AvKr1rzQczdAgMBAAE=&quot;</span><br><br>key_data = base64.b64decode(key_base) <span class="hljs-comment">#因为这里的解码是二进制数据，不是文本数据，所以不用decode</span><br><span class="hljs-comment"># 使用专门的 RSA 库解析二进制结构</span><br>public_key = RSA.import_key(key_data) <span class="hljs-comment">#这时public_key是一个对象，包含n和e</span><br>n = public_key.n    <span class="hljs-comment">#86934482296048119190666062003494800588905656017203025617216654058378322103517</span><br>e = public_key.e  <span class="hljs-comment">#65537</span><br><span class="hljs-comment">#n有了，那就是求p、q了，有专门的网站 https://factordb.com/</span><br>p = <span class="hljs-number">285960468890451637935629440372639283459</span><br>q = <span class="hljs-number">304008741604601924494328155975272418463</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><span class="hljs-comment">#这里你可以用 gmpy2 求模反元素 d ，我这里用的是 py3.8 的 pow来求得</span><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br><span class="hljs-comment">#目前根据 M = C(d) mod n , 只需要将flag.enc文件读取便可以求解,因为目前猜测只有flag.enc藏有密文，而且，他已经提示很明显了flag.enc</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    text = f.read()  <span class="hljs-comment">#这里把数据拿到了，赋值给text，这里text是字节数据</span><br><br>flag = bytes_to_long(text)  <span class="hljs-comment">#转换为整数用于计算</span><br>flag_long = <span class="hljs-built_in">pow</span>(flag,d,n)    <span class="hljs-comment">#这里是整数形式，需要转换为byte</span><br>flag = long_to_bytes(flag_long)<br><span class="hljs-built_in">print</span>(flag) <br><span class="hljs-comment">#b&#x27;\x02\x9d &#123;zR\x1e\x08\xe4\xe6\x18\x06\x00flag&#123;decrypt_256&#125;\n&#x27;</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>加密算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
