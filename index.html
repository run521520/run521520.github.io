<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="//github.githubassets.com">
  <link rel="preconnect" href="https://github.githubassets.com">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-一些边门的运算" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/%E4%B8%80%E4%BA%9B%E8%BE%B9%E9%97%A8%E7%9A%84%E8%BF%90%E7%AE%97/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.114Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="模运算的逆运算："><a href="#模运算的逆运算：" class="headerlink" title="模运算的逆运算："></a><strong>模运算的逆运算：</strong></h5><p><strong>加密后 &#x3D; (原始值 + 偏移) % 模值</strong>     </p>
<p>**原始值 &#x3D; (加密后 - 偏移 + 模值) % 模值    &#x2F;&#x2F;**这里加上模值是因为取模可能是负数</p>
<p>这个式子成立的关键是     0&lt;&#x3D; 原始值 &lt;&#x3D; 模值，这是字符加密的常见场景；</p>
<p>当不成立时就是 **原始值 &#x3D; (加密后 - 偏移 + 模值*k) % 模值 ,**你可以自己写一下数字，模拟一下；</p>
<h5 id="生成随机数："><a href="#生成随机数：" class="headerlink" title="生成随机数："></a><strong>生成随机数：</strong></h5><p><strong>rand(),srand()</strong></p>
<p>rand_num &#x3D; rand() % num +a  这里的num是生成数的区间，a是区间的左区间</p>
<p>对于区间[a, b)的随机整数：(rand() % (b-a)) + a</p>
<p>对于区间[a, b]的随机整数：(rand() % (b-a+1)) + a</p>
<p>srand()函数用于设置rand()函数生成随机数时所用的种子,</p>
<p>当用rand而不设种子时，后面的随机数是相同的，可以理解为rand函数是根据时间轴而生成数的，</p>
<p>rand生成数的时间轴需要srand来更换</p>
<p><strong>用法：</strong></p>
<p>用rand 需要引入头文件stdlib</p>
<p>需要引入<strong>time</strong>头文件，在开头写入<strong>srand((unsigned)time(NULL));</strong> 就行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/%E4%B8%80%E4%BA%9B%E8%BE%B9%E9%97%A8%E7%9A%84%E8%BF%90%E7%AE%97/" data-id="cuidP7IejjmyZyXrpFry5YXUM" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据储存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.104Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>数据的储存是从左到右的，意思左边是低位地址，右边是高位地址；</strong></p>
<h5 id="大小端："><a href="#大小端：" class="headerlink" title="大小端："></a><strong>大小端：</strong></h5><p>大端（存储）模式：是指数据的<strong>低位字节</strong>内容保存在内存的<strong>高地址处</strong>，而数据的<strong>高位字节</strong>内容，保存在内存的<strong>低地址</strong>处。</p>
<p>小端（存储）模式：是指数据的<strong>低位字节</strong>内容保存在内存的<strong>低地址处</strong>，而数据的<strong>高位字节</strong>内容，保存在内存的<strong>高地址</strong>处。</p>
<p>网络编程中,TCP&#x2F;IP统一采用大端方式传送数据，所以有时我们也会把大端方式称之为网络字节序。</p>
<p>特别需要注意的是，C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而 JAVA编写的程序则唯一采用big endian方式来存储数据</p>
<p>x86系列CPU都是little-endian的字节序；</p>
<p><strong>大端和小端的字节转换：</strong></p>
<p>当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序(即大端方式)后再进行传输。此外用C&#x2F;C++在小端方式的机器上编写的程序与java程序互通时也要进行大端和小端的转换。</p>
<p>这里所谓转换就是改变字节的排序，使交互时数据保持一致。举一个例子，还是16进制表示的数0x12345678，在小端机器上排序为0x78563412,当内存中这样的数传输时，在大端方式下就是0x78563412这个值，与原值不同，要想与原值相同，在传输前，在大端方式下就该是0x12345678，这时原数在内存中为0x12345678，即将原数据0x12345678在内存存储序列为0x12345678，也就是要转换成大端方式。</p>
<p>要传输值：12 34 56 78</p>
<p>不转换时，小端：78 56 34 12</p>
<p>转换为大端：12 34 56 78</p>
<p>在列如：</p>
<p>char s [] &#x3D; “abc”;</p>
<p>char ch[] &#x3D; “adf”</p>
<p>strcat(s,ch);</p>
<p>之后 s &#x3D; “abcadf”</p>
<p>同样的我们手动添加：</p>
<p>(char)a &#x3D; 0x10 , (char)d &#x3D; 0x13 , (char)f &#x3D; 0x15    将字符转换为十六进制</p>
<p>“abc”在内存中(小端)  是 0x151310</p>
<p>我们只需要将其for循环加到s后面就行了 注意一定要是10，13，15；</p>
<p>同理在看到列如  str &#x3D; “34adfg” &#x3D; (假设) 0x122354743523;</p>
<p>要手动加时，要从后面23-&gt;35-&gt;74-&gt;54-&gt;23-&gt;12才对</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98/" data-id="cuidNMFb-SD_ItoMdam2oNUw2" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-汇编" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/%E6%B1%87%E7%BC%96/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.099Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a><strong>寄存器：</strong></h3><p>在x86架构中，寄存器是cpu内部的高速存储区域，用常用于存放数据，指令地址和计算结果。</p>
<p>寄存器的大小通常与cpu的位数相关：</p>
<p>在32位x86架构中，寄存器的大小是32位（内存地址也是）</p>
<p>在64位x86架构中，寄存器的大小是64位（内存地址也是）</p>
<p><strong>x86寄存器中可以分以下几类：</strong></p>
<p>eax(EAX)：累加寄存器，常用于算数运算，I&#x2F;O操作。(windows中常用于存放结果返回值)</p>
<p>ebx(EBX)：基址寄存器，用于指向数组或数据结构的基址</p>
<p>ecx(ECX)：在windows中通常用于循环计数器或移位操作</p>
<p>edx(EDX)：数据寄存器，用于存储乘法，除法的结果</p>
<p>esi(ESI)：源索引寄存器用于指向源操作数，尤其是在字符串操作中。</p>
<p>edx(EDX)：目的索引寄存器，用于指向目标操作数，尤其是在字符串操作中</p>
<p>ebp(EBP)：基指针寄存器，用于保存栈帧的基地址（尤其是函数调用时，栈的管理非常依赖它）。栈底 — 因为 EBP 指向栈这种数据结构的底部，所以叫栈底</p>
<p>esp(ESP)：堆栈指针寄存器，用于指向当前栈顶位置，栈的 push&#x2F;pop 操作都依赖于它。栈顶 — 因为 ESP 指向栈这种数据结构的顶部，所以叫栈顶</p>
<p>在 x86-64（64 位）架构中，寄存器的名称略有变化，但功能类似：</p>
<p>RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP —— 这些是 64 位的扩展版本。</p>
<p><strong>指令指针寄存器：</strong></p>
<p>EIP:指令指针寄存器，它指向cpu正在执行的下一条指令的内存地址在64位中变为RIP</p>
<p>EIP只存在于cpu中，并没有汇编指令能直接修改它，</p>
<p>但是通常异常处理机制可以修改EIP</p>
<p><strong>标志寄存器：</strong></p>
<p>用于储存cpu执行后的状态信息，常见用途是在条件跳转如JZ,JC中判断依据</p>
<h3 id="汇编语言的基本结构："><a href="#汇编语言的基本结构：" class="headerlink" title="汇编语言的基本结构："></a><strong>汇编语言的基本结构：</strong></h3><p><strong>指令，操作数，标签，操作符</strong></p>
<p><strong>指令：</strong></p>
<p>指令代表cpu执行的一个操作，每条指令通常由操作码和操作数组成。</p>
<p>操作码：告诉cpu执行什么操作</p>
<p> 	如 MOV(数据传送)，ADD(加法)，SUB(减法)等</p>
<p>操作数：操作数可以是寄存器，内存地址，立即数(常数)，就是指定操作对象</p>
<p>列如：MOV EAX , 5</p>
<p>操作码：MOV 表示将数据传送到寄存器</p>
<p>操作数：EAX(寄存器) , 5(立即数)   表示将常数 5 立即存入 EAX中</p>
<p><strong>操作数：</strong></p>
<p>操作数是指令的参数，表示指令操作的对象。操作数通常有以下几种类型：</p>
<p>寄存器：如EAX , EBX表示cpu内部的寄存器 如： MOV EAX,EBX</p>
<p>内存地址：如 0X40100000</p>
<p> 	MOV EAX , 0X40100000</p>
<p>立即数就是常数</p>
<p><strong>操作符：</strong></p>
<p>操作符是汇编语言中执行运算的符号。</p>
<p>它可以是算术运算符(加，减)，逻辑操作符(与，或，非)，移位操作符(按位，或非)</p>
<p>常见的算数操作符： 常见的位操作符：</p>
<p>ADD: 加法							AND :按位与</p>
<p>SUB: 减法							OR: 按位与</p>
<p>MUL: 无符号乘法					XOR: 按位异或</p>
<p>DIV: 无符号除法					SHL: 逻辑左移</p>
<p>INC:自增								    SHR: 逻辑右移</p>
<p>DEC:自减</p>
<p><strong>mul</strong> <strong>作为无符号乘法 默认 EAX作为被乘数，操作数为乘数</strong></p>
<p>mov eax , 5</p>
<p>mov ecx , 2</p>
<p>mul ecx</p>
<p>&#x2F;&#x2F;eax &#x3D; 10 ,结果储存在EAX（低32位），高位结果储存在 EDX</p>
<p><strong>imul 有符号乘法 支持单操作，双操作，三操作</strong></p>
<p>单操作：默认被乘数在EAX</p>
<p>双操作：imul dest , src      dest作为目标寄存器储存结果</p>
<p>三操作：imul dest , src ,imm   将src*imm的结果储存到dest</p>
<p><strong>div 无符号除法 被除数 默认是 EDX:EAX 组成的64位整数，低32位在EAX</strong></p>
<p><strong>商储存在EAX , 余数储存在 EDX</strong></p>
<p><strong>需要确保 EDX 被清零（或正确设置），否则结果可能出错。</strong></p>
<p>mov edx , 0         &#x2F;&#x2F;这里是高位清零</p>
<p>mov eax , 15</p>
<p>mov ecx , 3</p>
<p>div ecx </p>
<p>eax &#x3D; eax &#x2F; ecx    ,   edx &#x3D; eax % ecx</p>
<p><strong>idiv 有符号除法 ，与div 类似，需要设置EDX,且结果符号由操作数符号决定</strong></p>
<p><strong>确保EDX符号开启：cdq 指令</strong></p>
<p>mov eax , -15</p>
<p>cdq</p>
<p>mov ecx , 3</p>
<p>idiv ecx</p>
<p>eax &#x3D; eax &#x2F; ecx &#x3D; -5   ,  edx &#x3D; eax % ecx &#x3D;0</p>
<p><strong>mul、imul、div 和 idiv 在反汇编技术和安全对抗中，既可以作为分析目标，也能用作保护手段：</strong></p>
<p><strong>攻击者可能利用它们的异常特性（如除零）或溢出特性来制造漏洞或反调试逻辑。</strong></p>
<p><strong>恶意软件可能使用这些指令混淆数据流，隐藏真实逻辑。</strong></p>
<p><strong>逆向工程师需要通过静态和动态分析工具，还原这些指令的逻辑和用途，从而解读隐藏意图。</strong></p>
<p><strong>栈：</strong></p>
<p><strong>push（入栈）将数据压入栈顶</strong></p>
<p><strong>pop（出栈） 将数据移除并返回</strong></p>
<p>他们操作的寄存器都是：esp 因为栈的特性是栈顶，而esp是控制栈顶的</p>
<p>所以 都是操作esp 的 ebp是栈底</p>
<p>mov 将数据从源传输到目的地位置 mov eax, ebx</p>
<p>push 将数据压入栈      push eax</p>
<p>pop  从栈中弹出数据到目的地 push eax</p>
<p>xchg 交换两个操作数的值  xchg eax,ebx</p>
<p>lea 取地址  lea eax,[ebx+4] 将ebx的地址加4给到eax</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/%E6%B1%87%E7%BC%96/" data-id="cuidevV3xGvx22NF6YHDtSfwZ" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Upx脱壳" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/Upx%E8%84%B1%E5%A3%B3/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.084Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>upx壳是一种压缩的壳，正常进入ida中会隐藏真正的汇编代码</p>
<p>首先将文件拖入PE中查看是否加壳和位数</p>
<p>在最后一行的info信息中如果出现upx，那就代表经过了upx加壳</p>
<p><strong>有针对脱壳的工具upx-5.0.2-win64</strong> </p>
<p>找到upx-5.0.2-win64文件中的upx后打开终端，然后输入 upx -d 程序名称</p>
<p>这里程序名称要的是绝对地址或相对地址，当然你也可以将程序拖到终端中</p>
<p>然后会自动脱壳，如果失败，根据提示具体解决</p>
<p>当然也有反upx脱壳工具的程序，也会导致脱壳失败，这是需要手动脱壳</p>
<p><strong>手动脱壳我们就需要找到加壳程序的OEP然后dump文件内存。</strong></p>
<p>(OEP原始程序入口点。EP(Entry Point)，意即程序的入口点。而OEP是程序的原始入口点，一个正常的程序只有EP，只有入口点被修改的程序(加壳等)，才会拥有OEP)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/Upx%E8%84%B1%E5%A3%B3/" data-id="cuidCT6RcBlgjFpyVXPVJnU6D" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-TEA加密算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.074Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TEA、XTEA、XXTEA算法采用64位的明文分组和128位的密钥。算法中使用了一个神秘常数δ（delta），它来源于黄金比率，用于保证每一轮加密都不相同。δ的精确值并不关键，通常定义为δ&#x3D;「(√5 - 1)2^31」（即0x9E3779B9），在做题中可能会变，但没有影响。</p>
<p> <strong>密钥长度</strong></p>
<p>TEA：使用128位密钥。</p>
<p>XTEA：通常使用128位或256位密钥。</p>
<p>XXTEA：密钥长度更灵活，可以使用任意长度的密钥。</p>
<p>&nbsp;<strong>加密轮数</strong></p>
<p>TEA：通常进行32轮加密。</p>
<p>XTEA：默认进行64轮加密。</p>
<p>XXTEA：加密轮数更多，具体轮数取决于数据块和密钥的长度。</p>
<p><strong>加密算法</strong></p>
<p>TEA：加密过程使用简单的加法、异或和移位操作。</p>
<p>XTEA：在TEA的基础上增加了更多的变量和操作，例如密钥的不规则混合。</p>
<p>XXTEA：进一步改进了轮加密过程，使用了更多的变量和操作，并且利用相邻字进行加密。</p>
<h5 id="TEA加密算法（公式）："><a href="#TEA加密算法（公式）：" class="headerlink" title="TEA加密算法（公式）："></a>TEA加密算法（公式）：</h5><p>&nbsp;	sum &#x3D; 0;</p>
<p>&nbsp;	delta &#x3D; 0x9e3779b9;</p>
<p>&nbsp;	for i &#x3D; 0 to 31</p>
<p>&nbsp;              sum +&#x3D; delta</p>
<p>&nbsp;		X0 +&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p>
<p>&nbsp;		X1 +&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p>
<p>&nbsp;	end for</p>
<p>&nbsp;	C0 &#x3D; X0;</p>
<p>&nbsp;	C1 &#x3D; X1;</p>
<p>解密：</p>
<p>&nbsp;	sum &#x3D; delta * 32;</p>
<p>&nbsp;	for i&#x3D;0 to 31</p>
<p>&nbsp;		X1 -&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p>
<p>&nbsp;		X0 -&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p>
<p>&nbsp;		sum -&#x3D; delta;</p>
<h5 id="XTEA加密算法（公式）"><a href="#XTEA加密算法（公式）" class="headerlink" title="XTEA加密算法（公式）:"></a>XTEA加密算法（公式）:</h5><p>&nbsp;	sum &#x3D; 0;</p>
<p>&nbsp;	delta &#x3D; 0x9e3779b9;</p>
<p>&nbsp;	for i &#x3D; 0 to Round</p>
<p>&nbsp;             	X0 +&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p>
<p>&nbsp;		sum +&#x3D; delta</p>
<p>&nbsp;		X1 +&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p>
<p>&nbsp;	end for</p>
<p>&nbsp;	C0 &#x3D; X0;</p>
<p>&nbsp;	C1 &#x3D; X1;</p>
<p>解密：</p>
<p>&nbsp;	sum &#x3D; delta * Round;</p>
<p>&nbsp;	for i &#x3D; 0 to Round</p>
<p>&nbsp;		X1 -&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p>
<p>&nbsp;		sum -&#x3D; delta</p>
<p>&nbsp;             	X0 -&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p>
<p>&nbsp;		end for</p>
<p>&nbsp;	C0 &#x3D; X0;</p>
<p>&nbsp;	C1 &#x3D; X1;</p>
<h5 id="XXTEA加密（公式）："><a href="#XXTEA加密（公式）：" class="headerlink" title="XXTEA加密（公式）："></a>XXTEA加密（公式）：</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" data-id="cuidfMLtwLNG4ZMOTOHOC24DW" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RC4加密算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:07:15.051Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>RC4 是典型的对称加密算法</strong></p>
<p>对称加密的核心特征是加密与解密过程依托同一密钥完成。在数据传输场景中：</p>
<p>发送方：利用密钥对明文执行加密变换，通过特殊算法将明文转化为复杂密文后对外传输；</p>
<p>接收方：需调用加密时的相同密钥，结合算法的逆运算对密文解密，还原出可读明文，以此保障数据传输的保密性。</p>
<p><strong>RC4 算法特性与安全性</strong></p>
<p>RC4 算法具备实现简单、运算高效的优势，其密钥长度支持动态调整，范围覆盖 1 - 256 字节（对应 8 - 2048 比特） 。加密时，会依据密钥及密钥长度生成密钥流，且密钥流长度与明文长度严格匹配，加密和解密流程复用同一算法逻辑，密钥流的生成完全由密钥内容与长度决定。</p>
<p>在现代技术环境下，当密钥长度达到 128 比特时，暴力枚举密钥的攻击方式已不具备可行性 。由于暴力破解需尝试近乎 “2^128” 数量级的密钥组合，计算量超乎现有算力承载极限，因此可预见在未来较长周期内，RC4 算法凭借其密钥长度设计，能够抵御暴力密钥搜索攻击。截至目前，针对 128 比特密钥长度的 RC4 加密，尚未出现经实践验证的有效攻击手段，一定程度上保障了算法应用的安全性。</p>
<p><strong>RC4 算法核心组成</strong></p>
<p>RC4 加密流程主要由两部分构成：</p>
<p>初始化算法（KSA，Key - Scheduling Algorithm）：负责对初始的密钥状态进行处理，基于输入密钥打乱内部状态数组，为后续生成密钥流做准备；</p>
<p>加密算法（PRGA，Pseudo - Random Generation Algorithm ，实际常与 KSA 协同表述）：依托 KSA 初始化后的状态，逐字节生成伪随机密钥流，通过密钥流与明文的按位异或（XOR）操作，完成加密（解密为逆过程，复用相同密钥流与异或逻辑 ），最终输出密文（或还原明文 ）。</p>
<p>#include&lt;stdio.h&gt;</p>
<p>#include&lt;string.h&gt;</p>
<p>&#x2F;&#x2F; 初始化RC4的S盒</p>
<p>void rc4_init(unsigned char *s, unsigned char *key, unsigned long key_len) {</p>
<p>&nbsp;   int i &#x3D; 0, j &#x3D; 0;</p>
<p>&nbsp;   unsigned char k[256] &#x3D; {0};</p>
<p>&nbsp;   unsigned char temp &#x3D; 0;</p>
<p>&nbsp;   </p>
<p>&nbsp;   &#x2F;&#x2F; 初始化S盒和K盒</p>
<p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p>
<p>&nbsp;       s[i] &#x3D; i;</p>
<p>&nbsp;       k[i] &#x3D; key[i % key_len];  &#x2F;&#x2F; 用密钥循环填充K盒</p>
<p>&nbsp;   }</p>
<p>&nbsp;   </p>
<p>&nbsp;   &#x2F;&#x2F; 打乱S盒</p>
<p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p>
<p>&nbsp;       j &#x3D; (j + s[i] + k[i]) % 256;</p>
<p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p>
<p>&nbsp;       temp &#x3D; s[i];</p>
<p>&nbsp;       s[i] &#x3D; s[j];</p>
<p>&nbsp;       s[j] &#x3D; temp;</p>
<p>&nbsp;   }</p>
<p>}</p>
<p>&#x2F;&#x2F; RC4加解密（数据会被直接修改）</p>
<p>void rc4_crypt(unsigned char *s, unsigned char *data, unsigned long len) {</p>
<p>&nbsp;   int i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;</p>
<p>&nbsp;   unsigned long k &#x3D; 0;</p>
<p>&nbsp;   unsigned char temp;</p>
<p>&nbsp;   </p>
<p>&nbsp;   for (k &#x3D; 0; k &lt; len; k++) {</p>
<p>&nbsp;       i &#x3D; (i + 1) % 256;</p>
<p>&nbsp;       j &#x3D; (j + s[i]) % 256;</p>
<p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p>
<p>&nbsp;       temp &#x3D; s[i];</p>
<p>&nbsp;       s[i] &#x3D; s[j];</p>
<p>&nbsp;       s[j] &#x3D; temp;</p>
<p>&nbsp;       &#x2F;&#x2F; 生成密钥流并异或</p>
<p>&nbsp;       t &#x3D; (s[i] + s[j]) % 256;</p>
<p>&nbsp;       data[k] ^&#x3D; s[t];</p>
<p>&nbsp;   }</p>
<p>}</p>
<p>int main() {</p>
<p>&nbsp;   unsigned char s[256] &#x3D; {0};</p>
<p>&nbsp;   char key[] &#x3D; “zhaosh”;               &#x2F;&#x2F; 密钥</p>
<p>&nbsp;   unsigned char data[] &#x3D; {12, 23, 3, 4, 4, 4, 3, 0x7F, 12, 1, 21, 3, 23};  &#x2F;&#x2F; 修正超出char范围的值</p>
<p>&nbsp;   unsigned long data_len &#x3D; sizeof(data);  &#x2F;&#x2F; 用sizeof计算二进制数据长度</p>
<p>&nbsp;   unsigned long key_len &#x3D; strlen(key);</p>
<p>&nbsp;   </p>
<p>&nbsp;   &#x2F;&#x2F; 加密过程</p>
<p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);</p>
<p>&nbsp;   rc4_crypt(s, data, data_len);</p>
<p>&nbsp;   printf(“加密后数据（十六进制）：”);</p>
<p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p>
<p>&nbsp;       printf(“%02X “, data[i]);  &#x2F;&#x2F; 用十六进制显示二进制数据</p>
<p>&nbsp;   }</p>
<p>&nbsp;   printf(“\n”);</p>
<p>&nbsp;   </p>
<p>&nbsp;   &#x2F;&#x2F; 解密过程（需要重新初始化S盒）</p>
<p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);  &#x2F;&#x2F; 重新初始化</p>
<p>&nbsp;   rc4_crypt(s, data, data_len);</p>
<p>&nbsp;   printf(“解密后数据（十进制）：”);</p>
<p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p>
<p>&nbsp;       printf(“%d “, data[i]);</p>
<p>&nbsp;   }</p>
<p>&nbsp;   printf(“\n”);</p>
<p>&nbsp;   </p>
<p>&nbsp;   return 0;</p>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" data-id="cuidfq2geRJyKLRPK_mknFcN1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ida使用文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/ida%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T17:43:33.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/ida%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/">ida使用文档</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>打开解析程序之后：</p>
<p>左边的是函数窗口：<br> 	按Ctrl + f  为查找函数名字，只要是表格窗口都可以用 Ctrl + f 搜索</p>
<p>IDA-View窗口：<br> 	汇编代码窗口，按空格键切换图形模式和文本模式</p>
<p>Pseudocode窗口：<br>伪代码窗口，在伪代码位置按下 tab 键可以切换到对应的汇编窗口，这里面就是我们学到的c&#x2F;c++语言窗口了；</p>
<p> 	点击关键词后按 N 键，可将关键词重命名；也可右键选择 “Rename global item”<br> <br>字符串窗口：<br> 	列举程序代码所引用到的字符串常量<br> 	Shift + F12 打开字符串窗口<br> 	Ctrl + F 可以弹出底部搜索小窗口，这里注意的是，因为是包含ida所识别的所有字符串，所以我们可以根据程序运行时，所给出的提示，来搜索相关的函数<br> <br>其他窗口：HEX View  ， Exports ， Imports ， Structures</p>
<p>菜单项 View 菜单中可以找到 IDA绝大部分窗口入口</p>
<!-- 其次是便捷键介绍 -->
<!-- Ctrl + X 交叉引用，按住某个字符串或变量，按Ctrl+x 会弹出引用该变量的函数

Ctrl + Z 撤回操作的意思

Alt + t 查找汇编指令，按F3可以直接找下一个(文本查找),当然也可以直接 Ctrl + F来搜

Alt + m 制作一个标签，添加描述

Ctrl + m 搜索标签，跳转到任意标签

\键  隐藏 *(_DWORD *)v3 = -858993460; 中的*(_DWORD *)  再次按 \ 又会出现

f5(相当于Tab键，如果F5没反应，那可能是你的f5有设置其他的快捷键) 反编译出类似于c代码的窗口

h键(记住Hex-View是16进制窗口便可记住,h相当于Hex-View的快捷键显示16进制) 10进制和16进制互换

d键 将IDA view-RIP解面的单个字节进行转换，可转换为2个，3个，4个，甚至更多个字节。

u键 将多个字节数据，甚至是汇编字节码进行拆分为单个字节的。

c键 重新分析为汇编代码

/键 在汇编解密也可以看到f5的伪代码，方便在汇编界面调试，前提是代码能f5

r键 转换为字符串类型的样子。

n键 修改变量 函数名称

y键 修改变量类型，使代码更加好看

m键 查看一些api的参数名称

p键 重新生成函数

还有些set ip呀，重新定义数组呀之类操作。 -->

<p>IDA调试器特性：<br>1.软件断点 &#x2F; 硬件断点 &#x2F; 条件断点 &#x2F; 脚本断点<br>2.步入 &#x2F; 步过 &#x2F; 步出函数 &#x2F; 执行到光标位置<br>3.汇编级 &#x2F; 伪代码级 &#x2F; 源码级<br>4.寄存器 &#x2F; 内存读写<br>5.启动进程调试 &#x2F; 附加调试</p>
<!-- 调试按钮介绍 -->
<!-- 
开始调试：

找到 debugger 后点击只有一个，然后选择 Local Windows debugger , 这样就可以调试了，

在要断点的地方按 F2 改行会显示红色

然后 点击 debugger 会有很多选项 找到 Start process 程序会运行到 断点处

选项：

1. Quick debug view
快速调试视图，一般用于快速查看调试过程中的关键信息，比如寄存器状态、内存数据等相关的概要信息，方便调试者快速定位和了解当前程序调试的状态。
2. Debugger windows
提供了与调试相关的各种子窗口，例如反汇编窗口、寄存器窗口、内存窗口等，通过这些子菜单可以打开或切换不同的调试辅助窗口，帮助调试人员从不同角度观察程序在调试过程中的运行情况。
3. Breakpoints
New breakpoint：设置新的断点，通过指定代码地址、条件等信息，让程序在运行到该位置时暂停，方便调试者检查此时的程序状态。
Edit breakpoint：编辑已有的断点属性，比如修改断点的触发条件、是否启用等。
Delete breakpoint：删除指定的断点。
Manage breakpoints：管理所有断点，可能包括批量操作断点（如全部禁用、全部删除等）、查看断点列表及其详细信息等功能。
4. Watches
观察窗口，用于添加要监视的变量、表达式等。在调试过程中，可以实时查看这些被监视对象的值的变化情况，帮助调试者了解程序运行时特定数据的状态。
5. Tracing
追踪调试功能，开启后可以记录程序执行的轨迹，比如记录程序执行过的指令序列等信息。这对于分析程序的执行流程、查找逻辑错误等非常有帮助，调试人员可以事后查看追踪记录来分析程序的行为。
6. Start process
按 F9 键可以触发该功能，用于启动一个新的进程并附加调试器，开始对新启动的进程进行调试。这是开始调试一个尚未运行的可执行程序的常用方式。
7. Attach to process
Start a new process in the debugger：在调试器中启动一个新进程，和 Start process 功能类似，都是启动新进程进行调试，但可能在一些启动参数设置、与现有调试环境的交互方式上略有差异。
Attach to running process：将调试器附加到一个已经在运行的进程上，从而可以对该进程进行调试。这适用于调试已经启动并在运行中的程序，比如分析某个服务程序运行时出现的问题。
Attach to remote process：连接到远程机器上正在运行的进程进行调试，在调试跨机器环境或者需要调试远程服务器上的程序时会用到。
8. Process options...
用于配置与进程调试相关的选项，例如设置调试进程的环境变量、工作目录，以及对调试进程的其他运行时参数进行调整，以满足特定的调试需求。
9. Pause process
暂停正在调试的进程，暂停后可以检查程序的当前状态，比如查看内存、寄存器、变量值等，方便定位问题。
10. Terminate process
终止正在调试的进程，结束该进程的运行，一般在调试过程中发现问题需要重新开始，或者确认程序出现严重错误无法继续调试时使用。
11. Detach from process
将调试器从正在调试的进程上分离，进程会继续按照正常的方式运行，而调试器不再对其进行控制。常用于调试过程中需要暂时停止调试但又不希望终止进程的情况。
12. Refresh memory
刷新内存视图，当程序运行过程中内存数据发生变化，而调试器的内存显示没有及时更新时，使用该功能可以重新读取内存数据并更新显示，确保调试人员看到的内存数据是最新的。
13. Take memory snapshot
对当前进程的内存状态进行快照，记录下某个时刻的内存数据。可以用于对比不同时刻的内存状态，查找内存泄漏、数据篡改等问题。
14. Step into
按 F7 键执行，单步调试进入函数内部，即当遇到函数调用时，调试器会进入被调用的函数，逐行执行函数内部的代码，方便调试者查看函数内部的执行逻辑和数据变化。
15. Step over
按 F8 键执行，单步调试但不进入函数内部。当遇到函数调用时，会把函数作为一个整体执行完，直接跳到函数调用后的下一条指令，适用于不想深入查看某个函数内部逻辑，只想快速跳过该函数调用继续调试后续代码的情况。
16. Run until return
按 Ctrl+F7 键执行，让程序继续运行，直到当前函数返回。常用于快速跳过某个函数内部的代码执行，直接查看函数执行完成后的状态。
17. Run to cursor
按 F4 键执行，让程序运行到光标所在的位置暂停，方便调试者快速定位到代码中的某个特定位置进行检查，而不需要逐行单步调试。
18. Switch to source
切换到对应的源代码视图，如果调试的程序有对应的源代码，并且调试器能够关联上，使用该功能可以快速跳转到与当前反汇编代码对应的源代码位置，方便调试人员对照查看。
19. Use source-level debugging
启用源码级调试模式，在该模式下，调试器会尽量按照源代码的逻辑来展示调试信息，以源代码行作为调试的基本单位，便于调试人员从更直观的源码角度来理解程序的执行过程。
20. Open source file...
打开指定的源代码文件，用于手动关联或查看与调试程序相关的源代码文件。
21. Debugger options...
打开调试器的全局配置选项，用于设置调试器的各种行为，比如设置内存显示格式、调试输出的详细程度、断点的默认属性等，以满足不同调试场景和个人习惯的需求。
22. Switch debugger...
切换调试器，当 IDA 支持多种调试器时（比如本地调试器、远程调试器等不同类型），使用该功能可以在不同的调试器之间进行切换，以适应不同的调试环境和需求。

-->
<p>在 Hex View 表中可以修改内存从而修改值<br>找到要修改的位置  按 F2 便可以修改了，之后在按 F2 便可修改成功 ， 或者右键找到 Edit 也可以<br>同时有一个插件 lazyIDA 可以直接将要修改的内容粘贴，不用一个一个修改 </p>
<!-- ida调试技巧-通过修改eip寄存器的值强制运行程序中存在但未被调用的函数 -->
<!-- 
eip寄存器用来存储CPU要读取指令的地址，CPU通过EIP寄存器读取即将要执行的指令，故而修改eip寄存器的值可以让cpu直接执行某函数
程序是32位时叫：eip
程序是64位时叫：rip

第一步找到要调用的函数地址(十六进制的)复制

然后找到要插入的位置，找到对应的汇编，设置断点，然后开始调试
右边会出现寄存器窗口，找到 EIP(RIP)双击值会出现窗口将值改变到要运行的函数地址
双击不行的话，点击 EIP(RIP)后 点击 edit(添加导出) 里面有一个 ...space 我忘记了，快捷键是右键

之后将断点取消，运行就行
 -->



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/22/ida%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/" data-id="cuid_rmjOURgO9YnODWyPAtew" data-title="ida使用文档" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/21/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T15:35:40.615Z" itemprop="datePublished">2025-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br>你好，世界。<br>我要开始我的创建博客之旅了</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/21/hello-world/" data-id="cuid0f6PAR0kb6KCnWNzDd-G_" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/24/%E4%B8%80%E4%BA%9B%E8%BE%B9%E9%97%A8%E7%9A%84%E8%BF%90%E7%AE%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/24/%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/24/%E6%B1%87%E7%BC%96/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/24/Upx%E8%84%B1%E5%A3%B3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/24/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>