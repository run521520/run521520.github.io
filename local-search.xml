<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ida使用文档</title>
    <link href="/2025/10/04/01_ida/"/>
    <url>/2025/10/04/01_ida/</url>
    
    <content type="html"><![CDATA[<h1 id="IDA-使用文档"><a href="#IDA-使用文档" class="headerlink" title="IDA 使用文档"></a>IDA 使用文档</h1><h2 id="一、窗口介绍"><a href="#一、窗口介绍" class="headerlink" title="一、窗口介绍"></a>一、窗口介绍</h2><h3 id="1-函数窗口"><a href="#1-函数窗口" class="headerlink" title="1. 函数窗口"></a>1. 函数窗口</h3><ul><li><strong>功能</strong>：显示所有函数列表。</li><li><strong>快捷键</strong>：<code>Ctrl + F</code> 查找函数名（所有表格窗口均支持）。</li></ul><h3 id="2-IDA-View-窗口"><a href="#2-IDA-View-窗口" class="headerlink" title="2. IDA-View 窗口"></a>2. IDA-View 窗口</h3><ul><li><strong>功能</strong>：显示汇编代码。</li><li><strong>快捷键</strong>：<code>空格键</code> 切换图形模式与文本模式。</li></ul><h3 id="3-Pseudocode（伪代码）窗口"><a href="#3-Pseudocode（伪代码）窗口" class="headerlink" title="3. Pseudocode（伪代码）窗口"></a>3. Pseudocode（伪代码）窗口</h3><ul><li><strong>功能</strong>：显示 C&#x2F;C++ 伪代码。</li><li><strong>快捷键</strong>：<code>Tab</code> 切换到对应汇编窗口。</li><li><strong>重命名</strong>：选中关键词后按 <code>N</code>，或右键选择“Rename global item”。</li></ul><h3 id="4-字符串窗口"><a href="#4-字符串窗口" class="headerlink" title="4. 字符串窗口"></a>4. 字符串窗口</h3><ul><li><strong>功能</strong>：列举程序引用的字符串常量。</li><li><strong>快捷键</strong>：<code>Shift + F12</code> 打开字符串窗口；<code>Ctrl + F</code> 搜索字符串。</li></ul><h3 id="5-其他窗口"><a href="#5-其他窗口" class="headerlink" title="5. 其他窗口"></a>5. 其他窗口</h3><ul><li><strong>HEX View</strong>：内存十六进制视图</li><li><strong>Exports</strong>：导出函数</li><li><strong>Imports</strong>：导入函数</li><li><strong>Structures</strong>：结构体定义</li></ul><blockquote><p><strong>提示</strong>：大部分窗口入口可在菜单栏 <code>View</code> 中找到。</p></blockquote><hr><h2 id="二、常用快捷键"><a href="#二、常用快捷键" class="headerlink" title="二、常用快捷键"></a>二、常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>Ctrl + X</code></td><td>查看交叉引用（字符串&#x2F;变量被引用的函数）</td></tr><tr><td><code>Ctrl + Z</code></td><td>撤销操作</td></tr><tr><td><code>Alt + T</code></td><td>查找汇编指令，<code>F3</code> 查找下一个</td></tr><tr><td><code>Alt + M</code></td><td>添加标签描述</td></tr><tr><td><code>Ctrl + M</code></td><td>搜索标签并跳转</td></tr><tr><td><code>\</code></td><td>隐藏&#x2F;显示类型转换（如 <code>*(_DWORD *)</code>）</td></tr><tr><td><code>F5</code>&#x2F;<code>Tab</code></td><td>反编译为 C 伪代码窗口</td></tr><tr><td><code>H</code></td><td>十六进制与十进制切换（Hex-View）</td></tr><tr><td><code>D</code></td><td>转换字节显示方式</td></tr><tr><td><code>U</code></td><td>拆分字节数据</td></tr><tr><td><code>C</code></td><td>重新分析为汇编代码</td></tr><tr><td><code>/</code></td><td>汇编界面显示伪代码（需支持 F5）</td></tr><tr><td><code>R</code></td><td>转换为字符串类型显示</td></tr><tr><td><code>N</code></td><td>修改变量&#x2F;函数名称</td></tr><tr><td><code>Y</code></td><td>修改变量类型</td></tr><tr><td><code>M</code></td><td>查看 API 参数名称</td></tr><tr><td><code>P</code></td><td>重新生成函数</td></tr></tbody></table><hr><h2 id="三、IDA-调试器功能"><a href="#三、IDA-调试器功能" class="headerlink" title="三、IDA 调试器功能"></a>三、IDA 调试器功能</h2><ol><li><strong>断点类型</strong>：软件断点、硬件断点、条件断点、脚本断点</li><li><strong>调试控制</strong>：步入、步过、步出、运行到光标</li><li><strong>调试级别</strong>：汇编级、伪代码级、源码级</li><li><strong>寄存器&#x2F;内存</strong>：读写寄存器与内存</li><li><strong>调试方式</strong>：启动进程调试、附加调试</li></ol><h3 id="调试相关菜单功能"><a href="#调试相关菜单功能" class="headerlink" title="调试相关菜单功能"></a>调试相关菜单功能</h3><ul><li><strong>Quick debug view</strong>：快速查看寄存器、内存等关键信息</li><li><strong>Debugger windows</strong>：打开调试辅助窗口（如反汇编、寄存器、内存等）</li><li><strong>Breakpoints</strong>：设置、编辑、删除、管理断点</li><li><strong>Watches</strong>：监视变量或表达式的值</li><li><strong>Tracing</strong>：记录程序执行轨迹，便于分析流程</li><li><strong>Start process</strong>：<code>F9</code> 启动新进程并调试</li><li><strong>Attach to process</strong>：附加到已运行进程或远程进程</li><li><strong>Process options…</strong>：配置调试进程参数（环境变量、工作目录等）</li><li><strong>Pause process</strong>：暂停进程，检查当前状态</li><li><strong>Terminate process</strong>：终止进程</li><li><strong>Detach from process</strong>：分离调试器，进程继续运行</li><li><strong>Refresh memory</strong>：刷新内存视图</li><li><strong>Take memory snapshot</strong>：内存快照，便于对比分析</li><li><strong>Step into</strong>：<code>F7</code> 单步进入函数</li><li><strong>Step over</strong>：<code>F8</code> 单步跳过函数</li><li><strong>Run until return</strong>：<code>Ctrl + F7</code> 运行至当前函数返回</li><li><strong>Run to cursor</strong>：<code>F4</code> 运行到光标处</li><li><strong>Switch to source</strong>：切换到源代码视图</li><li><strong>Use source-level debugging</strong>：启用源码级调试</li><li><strong>Open source file…</strong>：打开源代码文件</li><li><strong>Debugger options…</strong>：调试器全局配置</li><li><strong>Switch debugger…</strong>：切换不同类型调试器</li></ul><hr><h2 id="四、内存修改技巧"><a href="#四、内存修改技巧" class="headerlink" title="四、内存修改技巧"></a>四、内存修改技巧</h2><ul><li>在 <strong>Hex View</strong> 表中可直接修改内存数值。</li><li>找到要修改的位置，按 <code>F2</code> 进行编辑，再按一次 <code>F2</code> 确认修改。</li><li>右键选择 <code>Edit</code> 也可修改。</li><li>推荐插件：<strong>lazyIDA</strong>，可批量粘贴修改内容。</li></ul><hr><h2 id="五、调试技巧：通过修改-EIP-RIP-强制执行函数"><a href="#五、调试技巧：通过修改-EIP-RIP-强制执行函数" class="headerlink" title="五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数"></a>五、调试技巧：通过修改 EIP&#x2F;RIP 强制执行函数</h2><ul><li><strong>EIP</strong>（32位）或 <strong>RIP</strong>（64位）寄存器存储 CPU 下一条指令地址。</li><li>修改 EIP&#x2F;RIP 可让 CPU 跳转执行任意函数。</li></ul><p><strong>操作步骤：</strong></p><ol><li>找到目标函数地址（十六进制）。</li><li>在合适位置设置断点，开始调试。</li><li>在寄存器窗口双击 EIP&#x2F;RIP，修改为目标地址（或右键 Edit）。</li><li>取消断点，继续运行即可。</li></ol><hr><blockquote><p>本文档适用于 IDA Pro 基础及进阶使用，欢迎在博客留言交流更多技巧！</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RC4加密算法</title>
    <link href="/2025/10/04/02_RC4/"/>
    <url>/2025/10/04/02_RC4/</url>
    
    <content type="html"><![CDATA[<p><strong>RC4 是典型的对称加密算法</strong></p><p>对称加密的核心特征是加密与解密过程依托同一密钥完成。在数据传输场景中：</p><p>发送方：利用密钥对明文执行加密变换，通过特殊算法将明文转化为复杂密文后对外传输；</p><p>接收方：需调用加密时的相同密钥，结合算法的逆运算对密文解密，还原出可读明文，以此保障数据传输的保密性。</p><p><strong>RC4 算法特性与安全性</strong></p><p>RC4 算法具备实现简单、运算高效的优势，其密钥长度支持动态调整，范围覆盖 1 - 256 字节（对应 8 - 2048 比特） 。加密时，会依据密钥及密钥长度生成密钥流，且密钥流长度与明文长度严格匹配，加密和解密流程复用同一算法逻辑，密钥流的生成完全由密钥内容与长度决定。</p><p>在现代技术环境下，当密钥长度达到 128 比特时，暴力枚举密钥的攻击方式已不具备可行性 。由于暴力破解需尝试近乎 “2^128” 数量级的密钥组合，计算量超乎现有算力承载极限，因此可预见在未来较长周期内，RC4 算法凭借其密钥长度设计，能够抵御暴力密钥搜索攻击。截至目前，针对 128 比特密钥长度的 RC4 加密，尚未出现经实践验证的有效攻击手段，一定程度上保障了算法应用的安全性。</p><p><strong>RC4 算法核心组成</strong></p><p>RC4 加密流程主要由两部分构成：</p><p>初始化算法（KSA，Key - Scheduling Algorithm）：负责对初始的密钥状态进行处理，基于输入密钥打乱内部状态数组，为后续生成密钥流做准备；</p><p>加密算法（PRGA，Pseudo - Random Generation Algorithm ，实际常与 KSA 协同表述）：依托 KSA 初始化后的状态，逐字节生成伪随机密钥流，通过密钥流与明文的按位异或（XOR）操作，完成加密（解密为逆过程，复用相同密钥流与异或逻辑 ），最终输出密文（或还原明文 ）。</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>&#x2F;&#x2F; 初始化RC4的S盒</p><p>void rc4_init(unsigned char *s, unsigned char *key, unsigned long key_len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0;</p><p>&nbsp;   unsigned char k[256] &#x3D; {0};</p><p>&nbsp;   unsigned char temp &#x3D; 0;</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 初始化S盒和K盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       s[i] &#x3D; i;</p><p>&nbsp;       k[i] &#x3D; key[i % key_len];  &#x2F;&#x2F; 用密钥循环填充K盒</p><p>&nbsp;   }</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 打乱S盒</p><p>&nbsp;   for (i &#x3D; 0; i &lt; 256; i++) {</p><p>&nbsp;       j &#x3D; (j + s[i] + k[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;   }</p><p>}</p><p>&#x2F;&#x2F; RC4加解密（数据会被直接修改）</p><p>void rc4_crypt(unsigned char *s, unsigned char *data, unsigned long len) {</p><p>&nbsp;   int i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;</p><p>&nbsp;   unsigned long k &#x3D; 0;</p><p>&nbsp;   unsigned char temp;</p><p>&nbsp;   </p><p>&nbsp;   for (k &#x3D; 0; k &lt; len; k++) {</p><p>&nbsp;       i &#x3D; (i + 1) % 256;</p><p>&nbsp;       j &#x3D; (j + s[i]) % 256;</p><p>&nbsp;       &#x2F;&#x2F; 交换s[i]和s[j]</p><p>&nbsp;       temp &#x3D; s[i];</p><p>&nbsp;       s[i] &#x3D; s[j];</p><p>&nbsp;       s[j] &#x3D; temp;</p><p>&nbsp;       &#x2F;&#x2F; 生成密钥流并异或</p><p>&nbsp;       t &#x3D; (s[i] + s[j]) % 256;</p><p>&nbsp;       data[k] ^&#x3D; s[t];</p><p>&nbsp;   }</p><p>}</p><p>int main() {</p><p>&nbsp;   unsigned char s[256] &#x3D; {0};</p><p>&nbsp;   char key[] &#x3D; “zhaosh”;               &#x2F;&#x2F; 密钥</p><p>&nbsp;   unsigned char data[] &#x3D; {12, 23, 3, 4, 4, 4, 3, 0x7F, 12, 1, 21, 3, 23};  &#x2F;&#x2F; 修正超出char范围的值</p><p>&nbsp;   unsigned long data_len &#x3D; sizeof(data);  &#x2F;&#x2F; 用sizeof计算二进制数据长度</p><p>&nbsp;   unsigned long key_len &#x3D; strlen(key);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 加密过程</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“加密后数据（十六进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%02X “, data[i]);  &#x2F;&#x2F; 用十六进制显示二进制数据</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   &#x2F;&#x2F; 解密过程（需要重新初始化S盒）</p><p>&nbsp;   rc4_init(s, (unsigned char*)key, key_len);  &#x2F;&#x2F; 重新初始化</p><p>&nbsp;   rc4_crypt(s, data, data_len);</p><p>&nbsp;   printf(“解密后数据（十进制）：”);</p><p>&nbsp;   for (int i &#x3D; 0; i &lt; data_len; i++) {</p><p>&nbsp;       printf(“%d “, data[i]);</p><p>&nbsp;   }</p><p>&nbsp;   printf(“\n”);</p><p>&nbsp;   </p><p>&nbsp;   return 0;</p><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Base64加密算法</title>
    <link href="/2025/10/04/03_Base64/"/>
    <url>/2025/10/04/03_Base64/</url>
    
    <content type="html"><![CDATA[<p><strong>MD5和SHA256加密是不可逆的</strong></p><p><strong>base64是可逆的</strong></p><p>在python脚本中</p><p>开始要引入 base64</p><p>import 是引入的意思；</p><p><strong>import base64</strong></p><p>开始默认映射的是顺序是 <strong>“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>要解密的为data</p><p><strong>data &#x3D; “SGVsbG8gV29ybGQ&#x3D;”</strong></p><p>则flag为</p><p><strong>flag_byte &#x3D; base64.b64decode(data)</strong></p><p>这里是base64调用 b64decode()函数 ，该函数是将已经加密的字符返回</p><p>b64decode() 函数返回的是字节，需要经过 decode(“utf-8”) 转换为字符串</p><p><strong>flag &#x3D; flag_byte.decode(“utf-8”)</strong></p><p><strong>print(flag)</strong></p><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p><strong>有一些的变形：</strong></p><h4 id="映射改变了"><a href="#映射改变了" class="headerlink" title="映射改变了"></a><strong>映射改变了</strong></h4><p><strong>T1 &#x3D; “&#x2F;T+US9VR8WQ7XP6YO5ZN4aM3bL2cK1dJ0eIzfHygGxhFwiEvjDukCtlBsmArnqop”</strong></p><p><strong>target &#x3D; “NHPNOt5VdCixcy5JclLJLVHyLyauLMmC3CWeKl4lPRC&#x2F;“</strong></p><p>原本的是 :</p><p><strong>alphabet &#x3D; “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</strong></p><p>创建映射表并转换：</p><p><strong>创建映射表：str.maketrans(x,y)</strong></p><p>x中的第一个字符映射到y中的第一个字符，以此类推</p><p><strong>根据映射表替换字符串中的字符: string.translate(table)</strong></p><p><strong>translation_table &#x3D; str.maketrans(T1,alphabet)</strong></p><p><strong>standard_encoded &#x3D; target.translate(translation_table)</strong></p><p><strong>解码：</strong></p><p><strong>decoded_bytes &#x3D; base64.b64decode(standard_encoded)</strong></p><p><strong>flag &#x3D; decoded_bytes.decode(‘utf-8’)</strong></p><p><strong>print(flag)</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TEA加密算法</title>
    <link href="/2025/10/04/04_TEA/"/>
    <url>/2025/10/04/04_TEA/</url>
    
    <content type="html"><![CDATA[<p>TEA、XTEA、XXTEA算法采用64位的明文分组和128位的密钥。算法中使用了一个神秘常数δ（delta），它来源于黄金比率，用于保证每一轮加密都不相同。δ的精确值并不关键，通常定义为δ&#x3D;「(√5 - 1)2^31」（即0x9E3779B9），在做题中可能会变，但没有影响。</p><p> <strong>密钥长度</strong></p><p>TEA：使用128位密钥。</p><p>XTEA：通常使用128位或256位密钥。</p><p>XXTEA：密钥长度更灵活，可以使用任意长度的密钥。</p><p>&nbsp;<strong>加密轮数</strong></p><p>TEA：通常进行32轮加密。</p><p>XTEA：默认进行64轮加密。</p><p>XXTEA：加密轮数更多，具体轮数取决于数据块和密钥的长度。</p><p><strong>加密算法</strong></p><p>TEA：加密过程使用简单的加法、异或和移位操作。</p><p>XTEA：在TEA的基础上增加了更多的变量和操作，例如密钥的不规则混合。</p><p>XXTEA：进一步改进了轮加密过程，使用了更多的变量和操作，并且利用相邻字进行加密。</p><h5 id="TEA加密算法（公式）："><a href="#TEA加密算法（公式）：" class="headerlink" title="TEA加密算法（公式）："></a>TEA加密算法（公式）：</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to 31</p><p>&nbsp;              sum +&#x3D; delta</p><p>&nbsp;X0 +&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;X1 +&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * 32;</p><p>&nbsp;for i&#x3D;0 to 31</p><p>&nbsp;X1 -&#x3D; ((X0 &lt;&lt; 4) + K2) ^ (X0 + sum) ^ ((X0 &gt;&gt; 5) + K3);</p><p>&nbsp;X0 -&#x3D; ((X1 &lt;&lt; 4) + K0) ^ (X1 + sum) ^ ((X1 &gt;&gt; 5) + K1);</p><p>&nbsp;sum -&#x3D; delta;</p><h5 id="XTEA加密算法（公式）"><a href="#XTEA加密算法（公式）" class="headerlink" title="XTEA加密算法（公式）:"></a>XTEA加密算法（公式）:</h5><p>&nbsp;sum &#x3D; 0;</p><p>&nbsp;delta &#x3D; 0x9e3779b9;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;      X0 +&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;sum +&#x3D; delta</p><p>&nbsp;X1 +&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><p>解密：</p><p>&nbsp;sum &#x3D; delta * Round;</p><p>&nbsp;for i &#x3D; 0 to Round</p><p>&nbsp;X1 -&#x3D; (((X0 &lt;&lt; 4) ^ (X0 &gt;&gt; 5)) + X0) ^ (sum + key[(sum  &gt;&gt; 11)^ 3]);</p><p>&nbsp;sum -&#x3D; delta</p><p>&nbsp;      X0 -&#x3D; (((X1 &lt;&lt; 4) ^ (X1 &gt;&gt; 5)) + X1) ^ (sum + key[sum ^ 3]);</p><p>&nbsp;end for</p><p>&nbsp;C0 &#x3D; X0;</p><p>&nbsp;C1 &#x3D; X1;</p><h5 id="XXTEA加密（公式）："><a href="#XXTEA加密（公式）：" class="headerlink" title="XXTEA加密（公式）："></a>XXTEA加密（公式）：</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Upx脱壳</title>
    <link href="/2025/10/04/05_Upx/"/>
    <url>/2025/10/04/05_Upx/</url>
    
    <content type="html"><![CDATA[<p>upx壳是一种压缩的壳，正常进入ida中会隐藏真正的汇编代码</p><p>首先将文件拖入PE中查看是否加壳和位数<br>在最后一行的info信息中如果出现upx，那就代表经过了upx加壳</p><p>有针对脱壳的工具upx-5.0.2-win64 </p><p>找到upx-5.0.2-win64文件中的upx后打开终端，然后输入 upx -d 程序名称<br>这里程序名称要的是绝对地址或相对地址，当然你也可以将程序拖到终端中<br>然后会自动脱壳，如果失败，根据提示具体解决<br>当然也有反upx脱壳工具的程序，也会导致脱壳失败，这是需要手动脱壳</p><p>OEP(Original Entry Point)是程序的原始入口点的位置，EP(Entry Point)是程序的入口点，加壳之后，程序的入口点会被改动，所以有OEP，<br>需要从OEP开始脱壳，有两个指令，一个是pushad，还有popad，从pushad开始找，一直运行到结束</p><p>OEP：(Original Entry Point)，程序的原始入口点，软件加壳就是隐藏了EP， 只要我们找到程序的OEP，就可以立刻脱壳。<br>PUSHAD （压栈） 代表程序的入口点，POPAD （出栈） 代表程序的出口点，与PUSHAD相对应，一般找到这个OEP就在附近啦。</p><p>进入到程序里面后找到文件的入口<br>pushad意味着upx壳解压缩代码的入口。<br>64位程序中没有pushad，而是用几个push汇编代码替代。32位程序中存在pushad。<br>像这样的：<br>push rbx;<br>push rsi;<br>push rdi;<br>push rbp;  几个连一起的</p><p>第一就是用x32|64 找到入口：<br>点击断点 -&gt; 查找入口 -&gt; 找到之后点进去将第一行设为原始断点 EIP<br>-&gt; 之后按F8步过直到 ESP(FPU窗口) 发生变化 -&gt; 点击ESP右键找到”在内存窗口中转到” 点击<br>-&gt; 在地址窗口中将该地址右键 -&gt; 找到断点 -&gt;访问 -&gt; 2字节 -&gt; 之后便是运行会出现真正的函数窗口<br>-&gt; 之后便是用 Scylla x86 来将程序修复</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据储存</title>
    <link href="/2025/10/04/dataStorage/"/>
    <url>/2025/10/04/dataStorage/</url>
    
    <content type="html"><![CDATA[<h5 id="数据在内存中的表示方式"><a href="#数据在内存中的表示方式" class="headerlink" title="数据在内存中的表示方式"></a>数据在内存中的表示方式</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="bit-比特-位"><a href="#bit-比特-位" class="headerlink" title="bit(比特&#x2F;位)"></a>bit(比特&#x2F;位)</h5><h5 id="bit是计算机中最小的数据单位，只有两种状态开-1-关-1"><a href="#bit是计算机中最小的数据单位，只有两种状态开-1-关-1" class="headerlink" title="bit是计算机中最小的数据单位，只有两种状态开(1)关(1)"></a>bit是计算机中最小的数据单位，只有两种状态开(1)关(1)</h5><h5 id="计算机底层是数字电路，由晶体管组成，它们的工作状态-导通-截止-非常适用01"><a href="#计算机底层是数字电路，由晶体管组成，它们的工作状态-导通-截止-非常适用01" class="headerlink" title="计算机底层是数字电路，由晶体管组成，它们的工作状态(导通&#x2F;截止)非常适用01"></a>计算机底层是数字电路，由晶体管组成，它们的工作状态(导通&#x2F;截止)非常适用01</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="byte-字节"><a href="#byte-字节" class="headerlink" title="byte(字节)"></a>byte(字节)</h5><h5 id="1byte由8个bit组成，这是计算机信息处理的基本单位"><a href="#1byte由8个bit组成，这是计算机信息处理的基本单位" class="headerlink" title="1byte由8个bit组成，这是计算机信息处理的基本单位"></a>1byte由8个bit组成，这是计算机信息处理的基本单位</h5><h5 id="为什么是1byte-8bit-，-因为-1bit有两种状态则8bit，组合一起就是2-8-256"><a href="#为什么是1byte-8bit-，-因为-1bit有两种状态则8bit，组合一起就是2-8-256" class="headerlink" title="为什么是1byte&#x3D;8bit ， 因为 1bit有两种状态则8bit，组合一起就是2^8 &#x3D; 256"></a>为什么是1byte&#x3D;8bit ， 因为 1bit有两种状态则8bit，组合一起就是2^8 &#x3D; 256</h5><h5 id="这256中状态足以覆盖英文字母，数字，标点"><a href="#这256中状态足以覆盖英文字母，数字，标点" class="headerlink" title="这256中状态足以覆盖英文字母，数字，标点"></a>这256中状态足以覆盖英文字母，数字，标点</h5><h5 id="表示方式："><a href="#表示方式：" class="headerlink" title="表示方式："></a>表示方式：</h5><h5 id="二进制：-01101011"><a href="#二进制：-01101011" class="headerlink" title="二进制：  01101011"></a>二进制：  01101011</h5><h5 id="十六进制：0x6B-（这里是十六进制和二进制的转换-0110-6-1011-B）"><a href="#十六进制：0x6B-（这里是十六进制和二进制的转换-0110-6-1011-B）" class="headerlink" title="十六进制：0x6B （这里是十六进制和二进制的转换 0110 &#x3D; 6  1011&#x3D;B）"></a>十六进制：0x6B （这里是十六进制和二进制的转换 0110 &#x3D; 6  1011&#x3D;B）</h5><h5 id="十进制：-107"><a href="#十进制：-107" class="headerlink" title="十进制：  107"></a>十进制：  107</h5><h5 id="字符：-如果这个字符的值在ASCII的范围内，它可能代表一个字母-0x6B-‘k’"><a href="#字符：-如果这个字符的值在ASCII的范围内，它可能代表一个字母-0x6B-‘k’" class="headerlink" title="字符：    如果这个字符的值在ASCII的范围内，它可能代表一个字母 0x6B &#x3D; ‘k’"></a>字符：    如果这个字符的值在ASCII的范围内，它可能代表一个字母 0x6B &#x3D; ‘k’</h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="程序中的所有数据-数字，字符串，密钥-在内存中有意连续的字节形式存放的"><a href="#程序中的所有数据-数字，字符串，密钥-在内存中有意连续的字节形式存放的" class="headerlink" title="程序中的所有数据(数字，字符串，密钥)在内存中有意连续的字节形式存放的"></a>程序中的所有数据(数字，字符串，密钥)在内存中有意连续的字节形式存放的</h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="-7"><a href="#-7" class="headerlink" title=""></a></h5><h5 id="-8"><a href="#-8" class="headerlink" title=""></a></h5><h5 id="-9"><a href="#-9" class="headerlink" title=""></a></h5><h5 id="在汇编中-rsp和rbp是非常重要的寄存器，用于管理栈内存"><a href="#在汇编中-rsp和rbp是非常重要的寄存器，用于管理栈内存" class="headerlink" title="在汇编中 rsp和rbp是非常重要的寄存器，用于管理栈内存"></a>在汇编中 rsp和rbp是非常重要的寄存器，用于管理栈内存</h5><h5 id="rsp-栈指针寄存器（Stack-Pointer）"><a href="#rsp-栈指针寄存器（Stack-Pointer）" class="headerlink" title="rsp:栈指针寄存器（Stack Pointer）"></a>rsp:栈指针寄存器（Stack Pointer）</h5><h5 id="作用：始终指向栈顶"><a href="#作用：始终指向栈顶" class="headerlink" title="作用：始终指向栈顶"></a>作用：始终指向栈顶</h5><h5 id="特性：栈是“后进先出”的内存区域，用于临时存储数据-如函数参数，局部变量，返回地址等"><a href="#特性：栈是“后进先出”的内存区域，用于临时存储数据-如函数参数，局部变量，返回地址等" class="headerlink" title="特性：栈是“后进先出”的内存区域，用于临时存储数据(如函数参数，局部变量，返回地址等)"></a>特性：栈是“后进先出”的内存区域，用于临时存储数据(如函数参数，局部变量，返回地址等)</h5><h5 id="压栈-push-：rsp会自动减4-32位-或8-64位-然后将数据存入新的栈顶"><a href="#压栈-push-：rsp会自动减4-32位-或8-64位-然后将数据存入新的栈顶" class="headerlink" title="压栈(push)：rsp会自动减4(32位)或8(64位)然后将数据存入新的栈顶"></a>压栈(push)：rsp会自动减4(32位)或8(64位)然后将数据存入新的栈顶</h5><h5 id="弹栈-pop-：从栈顶取出数据，然后rsp自动加4-32位-或8-64位"><a href="#弹栈-pop-：从栈顶取出数据，然后rsp自动加4-32位-或8-64位" class="headerlink" title="弹栈(pop)：从栈顶取出数据，然后rsp自动加4(32位)或8(64位)"></a>弹栈(pop)：从栈顶取出数据，然后rsp自动加4(32位)或8(64位)</h5><h5 id="-10"><a href="#-10" class="headerlink" title=""></a></h5><h5 id="rbp：基址指针寄存器（Base-pointer）"><a href="#rbp：基址指针寄存器（Base-pointer）" class="headerlink" title="rbp：基址指针寄存器（Base pointer）"></a>rbp：基址指针寄存器（Base pointer）</h5><h5 id="作用：指向当前函数栈帧的基址，用于定位栈内的局部变量和函数参数"><a href="#作用：指向当前函数栈帧的基址，用于定位栈内的局部变量和函数参数" class="headerlink" title="作用：指向当前函数栈帧的基址，用于定位栈内的局部变量和函数参数"></a>作用：指向当前函数栈帧的基址，用于定位栈内的局部变量和函数参数</h5><h5 id="栈帧：每个函数调用时，会在栈上分配一块独立的内存区域-栈帧-，用于储存该函数的局部变量，参数等"><a href="#栈帧：每个函数调用时，会在栈上分配一块独立的内存区域-栈帧-，用于储存该函数的局部变量，参数等" class="headerlink" title="栈帧：每个函数调用时，会在栈上分配一块独立的内存区域(栈帧)，用于储存该函数的局部变量，参数等"></a>栈帧：每个函数调用时，会在栈上分配一块独立的内存区域(栈帧)，用于储存该函数的局部变量，参数等</h5><h5 id="函数进入时，通常会执行-push-rbp-保存上一个栈帧的基址-然后-mov-rbp-rsp-将当前的栈顶设为新栈帧的基址"><a href="#函数进入时，通常会执行-push-rbp-保存上一个栈帧的基址-然后-mov-rbp-rsp-将当前的栈顶设为新栈帧的基址" class="headerlink" title="函数进入时，通常会执行 push rbp(保存上一个栈帧的基址) 然后 mov rbp,rsp 将当前的栈顶设为新栈帧的基址"></a>函数进入时，通常会执行 push rbp(保存上一个栈帧的基址) 然后 mov rbp,rsp 将当前的栈顶设为新栈帧的基址</h5><h5 id="函数返回时，执行-mov-rsp-rbp-恢复栈顶-和-pop-rbp-恢复上一个的栈帧的基址"><a href="#函数返回时，执行-mov-rsp-rbp-恢复栈顶-和-pop-rbp-恢复上一个的栈帧的基址" class="headerlink" title="函数返回时，执行 mov rsp , rbp(恢复栈顶)和 pop rbp (恢复上一个的栈帧的基址)"></a>函数返回时，执行 mov rsp , rbp(恢复栈顶)和 pop rbp (恢复上一个的栈帧的基址)</h5><h5 id="-11"><a href="#-11" class="headerlink" title=""></a></h5><h5 id="push-rbp-保存上一个函数的-rbp"><a href="#push-rbp-保存上一个函数的-rbp" class="headerlink" title="push rbp        ; 保存上一个函数的 rbp"></a>push rbp        ; 保存上一个函数的 rbp</h5><h5 id="mov-rbp-rsp-新栈帧的基址-当前栈顶"><a href="#mov-rbp-rsp-新栈帧的基址-当前栈顶" class="headerlink" title="mov  rbp, rsp   ; 新栈帧的基址 &#x3D; 当前栈顶"></a>mov  rbp, rsp   ; 新栈帧的基址 &#x3D; 当前栈顶</h5><h5 id="sub-rsp-32-分配-32-字节给局部变量（rsp-下移）"><a href="#sub-rsp-32-分配-32-字节给局部变量（rsp-下移）" class="headerlink" title="sub  rsp, 32    ; 分配 32 字节给局部变量（rsp 下移）"></a>sub  rsp, 32    ; 分配 32 字节给局部变量（rsp 下移）</h5><h5 id="…-函数逻辑-…"><a href="#…-函数逻辑-…" class="headerlink" title="; … 函数逻辑 …"></a>; … 函数逻辑 …</h5><h5 id="mov-rsp-rbp-恢复栈顶到函数进入时的位置"><a href="#mov-rsp-rbp-恢复栈顶到函数进入时的位置" class="headerlink" title="mov  rsp, rbp   ; 恢复栈顶到函数进入时的位置"></a>mov  rsp, rbp   ; 恢复栈顶到函数进入时的位置</h5><h5 id="pop-rbp-恢复上一个函数的-rbp"><a href="#pop-rbp-恢复上一个函数的-rbp" class="headerlink" title="pop  rbp        ; 恢复上一个函数的 rbp"></a>pop  rbp        ; 恢复上一个函数的 rbp</h5><h5 id="ret-返回"><a href="#ret-返回" class="headerlink" title="ret             ; 返回"></a>ret             ; 返回</h5><h5 id="-12"><a href="#-12" class="headerlink" title=""></a></h5><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><h5 id="rsp-是动态的栈顶指针，负责栈的-“压入-弹出”-操作。"><a href="#rsp-是动态的栈顶指针，负责栈的-“压入-弹出”-操作。" class="headerlink" title="rsp 是动态的栈顶指针，负责栈的 “压入 &#x2F; 弹出” 操作。"></a>rsp 是动态的栈顶指针，负责栈的 “压入 &#x2F; 弹出” 操作。</h5><h5 id="rbp-是静态的栈帧基址指针，负责定位栈内的变量和参数"><a href="#rbp-是静态的栈帧基址指针，负责定位栈内的变量和参数" class="headerlink" title="rbp 是静态的栈帧基址指针，负责定位栈内的变量和参数"></a>rbp 是静态的栈帧基址指针，负责定位栈内的变量和参数</h5><h5 id="结合两者，可以清晰地分析函数的栈内存布局（局部变量、参数的存储位置），这对逆向工程和调试非常重要。"><a href="#结合两者，可以清晰地分析函数的栈内存布局（局部变量、参数的存储位置），这对逆向工程和调试非常重要。" class="headerlink" title="结合两者，可以清晰地分析函数的栈内存布局（局部变量、参数的存储位置），这对逆向工程和调试非常重要。"></a>结合两者，可以清晰地分析函数的栈内存布局（局部变量、参数的存储位置），这对逆向工程和调试非常重要。</h5><h5 id="-13"><a href="#-13" class="headerlink" title=""></a></h5><h5 id="-14"><a href="#-14" class="headerlink" title=""></a></h5><h5 id="-15"><a href="#-15" class="headerlink" title=""></a></h5><h5 id="-16"><a href="#-16" class="headerlink" title=""></a></h5><h5 id="-17"><a href="#-17" class="headerlink" title=""></a></h5><h5 id="-18"><a href="#-18" class="headerlink" title=""></a></h5><h5 id="-19"><a href="#-19" class="headerlink" title=""></a></h5><h5 id="-20"><a href="#-20" class="headerlink" title=""></a></h5><h5 id="-21"><a href="#-21" class="headerlink" title=""></a></h5><h5 id="-22"><a href="#-22" class="headerlink" title=""></a></h5><h5 id="-23"><a href="#-23" class="headerlink" title=""></a></h5><h5 id="-24"><a href="#-24" class="headerlink" title=""></a></h5><h5 id="-25"><a href="#-25" class="headerlink" title=""></a></h5><h5 id="-26"><a href="#-26" class="headerlink" title=""></a></h5><h5 id="-27"><a href="#-27" class="headerlink" title=""></a></h5><h5 id="-28"><a href="#-28" class="headerlink" title=""></a></h5><h5 id="-29"><a href="#-29" class="headerlink" title=""></a></h5><h5 id="-30"><a href="#-30" class="headerlink" title=""></a></h5><h5 id="-31"><a href="#-31" class="headerlink" title=""></a></h5><h5 id="-32"><a href="#-32" class="headerlink" title=""></a></h5><h5 id="-33"><a href="#-33" class="headerlink" title=""></a></h5><h5 id="-34"><a href="#-34" class="headerlink" title=""></a></h5><h5 id="-35"><a href="#-35" class="headerlink" title=""></a></h5><h5 id="-36"><a href="#-36" class="headerlink" title=""></a></h5><h5 id="-37"><a href="#-37" class="headerlink" title=""></a></h5><h5 id="-38"><a href="#-38" class="headerlink" title=""></a></h5><h5 id="-39"><a href="#-39" class="headerlink" title=""></a></h5><h5 id="-40"><a href="#-40" class="headerlink" title=""></a></h5><h5 id="-41"><a href="#-41" class="headerlink" title=""></a></h5><h5 id="-42"><a href="#-42" class="headerlink" title=""></a></h5><h5 id="-43"><a href="#-43" class="headerlink" title=""></a></h5><h5 id="-44"><a href="#-44" class="headerlink" title=""></a></h5><h5 id="-45"><a href="#-45" class="headerlink" title=""></a></h5><h5 id="-46"><a href="#-46" class="headerlink" title=""></a></h5><h5 id="-47"><a href="#-47" class="headerlink" title=""></a></h5><h5 id="-48"><a href="#-48" class="headerlink" title=""></a></h5><h5 id="-49"><a href="#-49" class="headerlink" title=""></a></h5><h5 id="-50"><a href="#-50" class="headerlink" title=""></a></h5><h5 id="-51"><a href="#-51" class="headerlink" title=""></a></h5><h5 id="-52"><a href="#-52" class="headerlink" title=""></a></h5><h5 id="-53"><a href="#-53" class="headerlink" title=""></a></h5><h5 id="-54"><a href="#-54" class="headerlink" title=""></a></h5><h5 id="-55"><a href="#-55" class="headerlink" title=""></a></h5><h5 id="-56"><a href="#-56" class="headerlink" title=""></a></h5><h5 id="-57"><a href="#-57" class="headerlink" title=""></a></h5><h5 id="-58"><a href="#-58" class="headerlink" title=""></a></h5><h5 id="-59"><a href="#-59" class="headerlink" title=""></a></h5><h5 id="-60"><a href="#-60" class="headerlink" title=""></a></h5><h5 id="-61"><a href="#-61" class="headerlink" title=""></a></h5><h5 id="-62"><a href="#-62" class="headerlink" title=""></a></h5><h5 id="-63"><a href="#-63" class="headerlink" title=""></a></h5><h5 id="-64"><a href="#-64" class="headerlink" title=""></a></h5><h5 id="-65"><a href="#-65" class="headerlink" title=""></a></h5><h5 id="-66"><a href="#-66" class="headerlink" title=""></a></h5><h5 id="-67"><a href="#-67" class="headerlink" title=""></a></h5><h5 id="-68"><a href="#-68" class="headerlink" title=""></a></h5><h5 id="-69"><a href="#-69" class="headerlink" title=""></a></h5><h5 id="-70"><a href="#-70" class="headerlink" title=""></a></h5><h5 id="-71"><a href="#-71" class="headerlink" title=""></a></h5><h5 id="-72"><a href="#-72" class="headerlink" title=""></a></h5><h5 id="-73"><a href="#-73" class="headerlink" title=""></a></h5><h5 id="-74"><a href="#-74" class="headerlink" title=""></a></h5><h5 id="-75"><a href="#-75" class="headerlink" title=""></a></h5><h5 id="-76"><a href="#-76" class="headerlink" title=""></a></h5><h5 id="-77"><a href="#-77" class="headerlink" title=""></a></h5><h5 id="-78"><a href="#-78" class="headerlink" title=""></a></h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>另外一些加密算法</title>
    <link href="/2025/10/04/otherAlgorithms/"/>
    <url>/2025/10/04/otherAlgorithms/</url>
    
    <content type="html"><![CDATA[<h3 id="凯撒加密："><a href="#凯撒加密：" class="headerlink" title="凯撒加密："></a><strong>凯撒加密：</strong></h3><p>就是将明文中的所有字母全部偏移key个单位，来进行联系</p><p>加密：</p><p>model1 &#x3D; “abcdefghijklmnopqrstuvwxyz”</p><p>model2 &#x3D; “ABCDEFGHIJKLMNOPQRSTUVWXYZ”</p><p>str1 &#x3D; “flag{i_LOVE_Reverse}”</p><p>key &#x3D; 11</p><p>for s in  str1:</p><p>&nbsp;if s.islower():</p><p>&nbsp;n &#x3D; model1.find(s)</p><p>&nbsp;s &#x3D; model1[(n+key)%26]  &#x2F;&#x2F;防止超载</p><p>&nbsp;elif s.isupper():</p><p>&nbsp;n &#x3D; model1.find(s)</p><p>&nbsp;s &#x3D; model1[(n+key)%26]</p><p>&nbsp;print(s,end&#x3D;’’)</p><p>加密后的明文</p><p>str1 &#x3D; “qwlr{t_WZGP_Cpgpcdp}”</p><p>解密：</p><p>for i in range(1,27):</p><p>&nbsp;for s in str1:</p><p>&nbsp;if s.islower():</p><p>&nbsp;n &#x3D; model1.find(s)</p><p>&nbsp;s &#x3D; model1[(n-key)%26] &#x2F;&#x2F;防止出现负数</p><p>&nbsp;elif s.isupper():</p><p>&nbsp;n &#x3D; model2.find(s)</p><p>&nbsp;s &#x3D; model2[(n-key)%26] </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些偏门的运算</title>
    <link href="/2025/10/04/SomeNicheOperations/"/>
    <url>/2025/10/04/SomeNicheOperations/</url>
    
    <content type="html"><![CDATA[<h5 id="模运算的逆运算："><a href="#模运算的逆运算：" class="headerlink" title="模运算的逆运算："></a><strong>模运算的逆运算：</strong></h5><p><strong>加密后 &#x3D; (原始值 + 偏移) % 模值</strong>     </p><p>**原始值 &#x3D; (加密后 - 偏移 + 模值) % 模值    &#x2F;&#x2F;**这里加上模值是因为取模可能是负数</p><p>这个式子成立的关键是     0&lt;&#x3D; 原始值 &lt;&#x3D; 模值，这是字符加密的常见场景；</p><p>当不成立时就是 **原始值 &#x3D; (加密后 - 偏移 + 模值*k) % 模值 ,**你可以自己写一下数字，模拟一下；</p><h5 id="生成随机数："><a href="#生成随机数：" class="headerlink" title="生成随机数："></a><strong>生成随机数：</strong></h5><p><strong>rand(),srand()</strong></p><p>rand_num &#x3D; rand() % num +a  这里的num是生成数的区间，a是区间的左区间</p><p>对于区间[a, b)的随机整数：(rand() % (b-a)) + a</p><p>对于区间[a, b]的随机整数：(rand() % (b-a+1)) + a</p><p>srand()函数用于设置rand()函数生成随机数时所用的种子,</p><p>当用rand而不设种子时，后面的随机数是相同的，可以理解为rand函数是根据时间轴而生成数的，</p><p>rand生成数的时间轴需要srand来更换</p><p><strong>用法：</strong></p><p>用rand 需要引入头文件stdlib</p><p>需要引入<strong>time</strong>头文件，在开头写入<strong>srand((unsigned)time(NULL));</strong> 就行</p><h4 id="使用-Python-的numpy库直接求解线性方程组"><a href="#使用-Python-的numpy库直接求解线性方程组" class="headerlink" title="使用 Python 的numpy库直接求解线性方程组"></a>使用 Python 的numpy库直接求解线性方程组</h4><p>当有解方程组是多元的时候就用</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
